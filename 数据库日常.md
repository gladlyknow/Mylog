  file# 857 block# 2938801 slot 19 not found

select *  from dba_extents where file_id=857 and 2938801 between block_id and block_id+blocks-1;
  
 execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_197929',task_owner => 'SYS', replace => TRUE);
sys_login_log_history
DBMS_SQLTUNE包使用
cat sqlid.txt|while read sql_id
do
sqlplus / as sysdba <!
spool /tmp/${sql_id}.txt
set wra on
set long 999999
col task format a300
set serveroutput on size 999999
set LONGC 99999
set linesize 32000
set pagesize 9999
var  my_recomm   CLOB;
DECLARE
my_task_name VARCHAR2(30);
BEGIN
my_task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK( sql_id    => '4jtk0uwx3sm2b' );
DBMS_SQLTUNE.EXECUTE_TUNING_TASK( task_name => my_task_name );
select DBMS_SQLTUNE.REPORT_TUNING_TASK( my_task_name ) into :my_recomm from dual;
END;
/

 create index TLGDZH.IDX$$_04010001 on TLGDZH.P_MSG_SEND("RCVER_NO","MSG_STATUS_CODE","MSG_REMIND_CODE","MSG_SORT_CODE") tablespace IDX_GDZH;

SYS_SQLPROF_026f6558aa2a0000

4zz56j7xw1nf3
execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_241268',task_owner => 'SYS', replace => TRUE);

8bta8y8pmgbvz
4ht00myt1qvd3
execute dbms_stats.gather_table_stats(ownname => 'SGRCA_OWNER', tabname=> 'ES_CONS_SNAP', estimate_percent =>DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR ALL COLUMNS SIZE AUTO');
            
execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_156163',task_owner => 'SYS', replace => TRUE);
execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_155691',task_owner => 'SYS', replace => TRUE);
execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_155677',task_owner => 'SYS', replace => TRUE);


select name,VALUE_STRING from  v$sql_bind_capture where sql_id = '5y1mnw6za1maf';
select * from  v$sql_bind_capture where sql_id = '&1';
select * from dba_hist_sqlbind where sql_id = '52v5ffhk2215p';
select * from dba_hist_sqlbind where sql_id = '&1';
 index(id, data_date) local;

select 'exec sys.dbms_shared_pool.purge('''||address||','||hash_value||''','||'''c'');' from v$sqlarea where sql_id='&1';
c030uu7xuah02
tqydzy2019
set linesize 200
set pagesize 99999
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
col sql_id format a20
col OSUSER format a10
col username format a10
col inst_id format 9999999
col BLOCKING_SESSION format 999999
col BLOCKING_INSTANCE format 999999
set wra off
select saddr,sid,serial#,BLOCKING_SESSION,BLOCKING_instance,WAIT_TIME,event,p1,p2, program,sql_id,username
from v$session  b  
where 
wait_class<>'Idle' --and username='SYS' and upper(PROGRAM) like '%SQLPLUS%'--and username='GOLDENGATE'--and EVENT='library cache lock'--and username='SYS' ---and  sql_id='81buj56smmvn4'
order by sql_id

coe_3fh9cqfn8wqtg_3761605562
select 'alter system kill session '''||sid||','||serial#||''' immediate;' from v$session where sql_id in('5hcy5g7ca0a3w','1p5t64zgqa6qs','1xnpb2hn3r0ym');
select 'alter system kill session '''||sid||','||serial#||''' immediate;' from v$session where sql_id='MW_SYS';
select 'alter system kill session '''||sid||','||serial#||''' immediate;' from v$session where sql_id='MW_APP';
select 'alter system kill session '''||sid||','||serial#||''' immediate;' from v$session where PROGRAM='plsqldev.exe' and wait_class<>'Idle';

       46 63ng1gwmu5y1m
       106 1p5t64zgqa6qs
       287 1xnpb2hn3r0ym
       
set linesize 300
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
col sql_id format a20
col OSUSER format a10
col username format a10
col inst_id format 999999
set wra off
select saddr,sid,serial#,BLOCKING_SESSION,BLOCKING_INSTANCE,WAIT_TIME,event,p1,p2, program,sql_id,OSUSER,username
from v$session  b  
where  wait_class<>'Idle' --and username like 'DSG%'
order by sql_id;

SELECT sysdate, '86' appid,a.tablespace_name, a.free_mb,b.size_mb,Trunc((a.free_mb/b.size_mb) * 100) FREE_statio FROM   (SELECT tablespace_name, Trunc(Sum(bytes)/1024/1024) free_mb FROM   dba_free_space  GROUP BY tablespace_name) a,    (SELECT tablespace_name,  Trunc(Sum(bytes)/1024/1024) size_mb   FROM   dba_data_files  GROUP BY tablespace_name) b WHERE a.tablespace_name(+) = b.tablespace_name  order by a.free_mb

查询执行计划：
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_cursor('&1'));

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_AWR('gwqt70vnrsqpj'));
d19rfap5hud81
61tsvwxb12k3y
execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_39015',task_owner => 'SYS', replace => TRUE);
3buvw48uzq248

259z080d24wtu

3buvw48uzq248
bn7gkpdms8yn6

select sql_id,count(*) from v$session where wait_class<>'Idle' group by sql_id
having count(*)>1
order by count(*)


set wra on
set long 99999
select sql_fulltext from gv$sqlarea where sql_id='&1';


set linesize 300
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
col sql_id format a20
col OSUSER format a10
col username format a30
col inst_id format 999999
set wra off
select username,saddr,sid,serial#,BLOCKING_SESSION,BLOCKING_INSTANCE,WAIT_TIME,event,p1,p2, program,sql_id,OSUSER
from v$session  b  
where  wait_class<>'Idle' --and username='SYS' --and OSUSER='weblogic'
order by sql_id;

select 'alter system kill session '''||sid||','||serial#||''' immediate;' from v$session where sql_id ='&1' and EVENT='SQL*Net more data to client'
select 'alter system kill session '''||sid||','||serial#||''' immediate;' from v$session where username='YJSJZCPT' and osuser='yarn'  and rownum<11;
select 'alter system kill session '''||sid||','||serial#||''' immediate;' from v$session where sql_id='&1';

8:30--9A:30

select 'alter system kill session '''||sid||','||serial#||''' immediate;' from v$session where  wait_class<>'Idle' and username='EXCHANGER30' and OSUSER='weblogic'

select '!kill -9 '||b.spid from v$session a,v$process b where a.username='YJSJZCPT' and a.osuser='yarn' 
and  a.paddr=b.addr ;

select 'alter system kill session '''||sid||','||serial#||''' immediate;' from v$session where sql_id ='3fh9cqfn8wqtg';

select  event,sql_id,count(*) from v$session  b  
where  wait_class<>'Idle' 
group by event,sql_id
order by count(*);

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('4nqyd20g6s52x'));

execute dbms_stats.gather_table_stats(ownname => 'SYS', tabname =>'RECYCLEBIN$', estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,method_opt => 'FOR ALL COLUMNS SIZE AUTO');
execute dbms_stats.gather_index_stats(ownname => 'SAPSR3', indname =>'"ANEK~1"', estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE);
 
SQL> 
select address,hash_value||'' from v$sqlarea where sql_id='&1';
3r1j7mgvzr163

SQL> exec sys.dbms_shared_pool.purge('0000003F4C1F05A0,4160455875','c');

exec sys.dbms_shared_pool.purge('&1,&2','c');
select TASK_NAME,CREATED,STATUS from user_advisor_tasks where TASK_NAME='TASK_39365';
select dbms_sqltune.report_tuning_task('TASK_39365') from dual;
execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_39365',replace => TRUE);
create index SAPSR3.IDX$$_FA5D000 on SAPSR3.BWFIAA_AEDAT_TR('AEDAT');
print :my_recomm

----baseline
exec :cnt:=DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(sql_id=>'7wk6f1snaby67', plan_hash_value => 1456006572,enabled=> 'YES');
exec DBMS_SQLTUNE.DROP_SQL_PROFILE('SYS_SQLPROF_0253f01a01660002');
explain plan for
delete  from sgrca_owner.es_consprc_tact_snap a  where (a.org_no=:b1 and exists
(select 1  from sgrca_owner.es_cons_snap xa where ((xa.org_no=:b1 and
xa.batch_no=:b3) and a.calc_id=xa.calc_id)))
7vsd4rxam2yd7
1. 
一个SQL，通过SPM固定它的执行计划，可以通过DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE实现。也可以通地此功能在不修改原SQL的情况下对其加HINT来固定执行计划。
DB VERSION:Oracle 11.2.0.4
OS:CentOS 6.6
例如：
原SQL走索引：
SELECT * FROM SCOTT.TB_SPM WHERE OBJECT_ID=10;
想通过加HINT让其走全表扫描：
SELECT /*+FULL(TB_SPM)*/* FROM SCOTT.TB_SPM WHERE OBJECT_ID=10;
在V$SQL中查询出，原SQL的SQL_ID=064qcdmgt6thw，加HINT的SQL的SQL_ID=ahdtbgvsd3bht,PLAN_HASH_VALUE=970476072。
执行以下：
DECLARE
  CNT  NUMBER;
  V_SQL CLOB;
BEGIN
  --得到原语句SQL文本
  SELECT SQL_FULLTEXT INTO V_SQL FROM V$SQL WHERE SQL_ID = '064qcdmgt6thw' AND ROWNUM=1;
  --用加HINT的SQL的SQL_ID和PLAN_HASH_VALUE，来固定原语句的SQL
  CNT := DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(SQL_ID          => 'ahdtbgvsd3bht',
                                              PLAN_HASH_VALUE => 970476072,
                                              SQL_TEXT        => V_SQL);
END;

这样就将加HINT的执行计划固定在原语句上。执行原语句，在V$SQL的PLAN_HASH_VALUE列和SQL_PLAN_BASELINE列来确认是否固定。
测试中发现，一些含有绑定变量的SQL，用常量的SQL的SQL_ID和PLAN_HASH_VALUE无法固定，此时可以尝试使用EXECUTE IMMEDIATE来生成含有绑定变量的SQL。
例如：
DECLARE
  V_SQL VARCHAR2(3000);
BEGIN
  V_SQL := 'SELECT /*+FULL(TB_SPM)*/* FROM SCOTT.TB_SPM WHERE OBJECT_ID=:1';
  EXECUTE IMMEDIATE V_SQL
    USING 10;
END;
或
var v number;
exec :v :=10
SELECT /*+FULL(TB_SPM)*/* FROM SCOTT.TB_SPM WHERE OBJECT_ID=:V;
######baseline#################

锁定统计信息： 
exec dbms_stats.set_table_stats('TEST1','T1',NUMROWS=>10000);
exec dbms_stats.lock_table_stats('','T1',cascade=>true);
 pub_smsdata_info_det  
set long 999999
set linesize 200
set longc 99999
select a.* from table(dbms_xplan.display_cursor('4vmtbc8mq63d9',null,'ADVANCED'))a

1k3wkbgjbuj1v
2hcp91b9kr89q

gsb77c6kuzwz5

fz5zybthuupfv

查询 1047534129
variable cnt number;
exec :cnt:=DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(sql_id=>'7vsd4rxam2yd7', plan_hash_value => 1047534129,enabled=> 'YES');
select sql_text,enabled from dba_sql_plan_baselines;(能查询该语句).
exec DBMS_SQLTUNE.DROP_SQL_PROFILE('SYS_SQLPROF_0166cca521c80001');
删除一个无用的执行计划
保留一个最好的！
select  count(*) from v$log;
--------------------
---锁阻塞语句查询
 select q.sql_id,q.sql_text from v$sqlarea q ,v$session s ,v$lock l 
 where l.block=1 and l.sid=s.sid and s.sql_id=q.sql_id
g2xu57704hsw7
 cw3t14tuppzwh                4
 cw3t14tuppzwh
 cj340xhsg4jxf
查询执行计划：
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&1'));
5bkrh1fpn5t75


select * from 
select * from SGRCA_OWNER.A_RCA_TACTIC_DET  WHERE TACTIC_DET_ID ='2019303911030282'
 execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_41146',replace => TRUE);
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&1'));
select a.* from table(dbms_xplan.display_cursor('&1',null,'ADVANCED'))a;
33jupzt6sbd8h

52v5ffhk2215p

select distinct plan_hash_value from v$sql_plan where sql_id='9gsapmdh7kkx6' and child_number='0';
4yvxy8q9u5n0m
execute dbms_stats.gather_index_stats(ownname => 'SGPMS_PM', indname =>'IND_S_DEV_IR_APPNO', estimate_percent =>DBMS_STATS.AUTO_SAMPLE_SIZE,degree=>8);
execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_41153',replace => TRUE);
1362328603
@?/rdbms/admin/utlxplan
@?/rdbms/admin/utlxpls
explain plan for delete  from SGRCA_OWNER.es_cons_prc_amt a  where (a.org_no=:b1 and exists (select 1  from SGRCA_OWNER.es_cons_snap b where ((b.org_no=:b1 and b.batch_no=:b3) and b.calc_id=a.calc_id)))

exec dbms_workload_repository.create_snapshot();
mtsrecover
固定执行计划：
declare  
m_clob clob;  
begin  
select sql_fulltext  
into m_clob  
from v$sql  
where sql_id = 'day4zwzuhxjnd'  
and child_number = 0;  
dbms_output.put_line(m_clob);  
dbms_output.put_line(dbms_spm.load_plans_from_cursor_cache(  
sql_id          => '7p0d5fu52yy6a',  
plan_hash_value => 1956636844,  
sql_text        => m_clob,  
fixed           => 'YES',   
enabled         => 'YES'));  
end;  
/  
查补丁：
col ACTION_TIME format a30
set linesize 200
select ACTION_TIME,ACTION,NAMESPACE,VERSION,BUNDLE_SERIES,ID from registry$history; 

 execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_19424',task_owner => 'SYS', replace => TRUE);

drop index IDX$$_12010001
/
select table_name,LAST_ANALYZED from dba_tab_statistics and table_name like 'X$%' and LAST_ANALYZED is null;
 select /*+rule*/ * from dba_tables where owner='FMIS2000';

select sum(bytes/1024/1024/1024) from dba_segments where owner='SGPMS';
 pub_rcv_ctrl_log  

a_rca_tactic_task
select status from dba_indexes where table_name=upper('a_rca_tactic_task');
set linesize 200
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
col sql_id format a20
col OSUSER format a10
col username format a10
col inst_id format 999999
set wra off
select sid,serial#,BLOCKING_SESSION,BLOCKING_INSTANCE,WAIT_TIME,event,p1,p2, program,sql_id,OSUSER,username from v$session  b  
where  wait_class<>'Idle' -- and username='SYS'
order by sql_id;
cc
order by sql_id
and event='enq: TX - row lock contention'

select * from gv$lock where block=1;
select * from gv$locked_object
---- and username='&1'--
EXCHANGER3
alter database recover managed standby database using current logfile disconnect from session;
select sum(blocks*8192/1024/1024) from v$sort_usage;

YMrt-.001 
and event not like '%dblink%' and username='EXCHANGER30'
and username='TP';
and event='direct path read' order by sql_id
/
select sql_id,count(*) from v$session where wait_class<>'Idle' group by sql_id order by count(*);
Fjks_131
set linesize 250
set pagesize 200
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
col sql_id format a20
col OSUSER format a10
col username format a10
col inst_id format 999999
select sid,serial#,WAIT_TIME,event,p1,p2, program,sql_id,OSUSER,COMMAND,username
from gv$session  b  
where wait_class<>'Idle'
order by sql_id

Zhwg-.93313
PLSQLDev.exe 
alter diskgroup data add disk '/dev/rdsk/c0t6005076306FFD3990000000000002411d0s6' name DATA_0025;
alter diskgroup diskgroup_name undrop disks;

set linesize 250
set pagesize 200
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
col OSUSER format a10
col username format a10
select sid,serial#,p1,p2,blocking_session,event, program,sql_id,OSUSER,COMMAND,username,machine
from gv$session  b  
where  username='SGDC_PMS2'
order by sql_id

Ozfpsy-.165  

set linesize 250
set pagesize 200
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
col OSUSER format a10
col username format a10
select inst_id,sid,serial#,p1,p2,blocking_session,event, program,sql_id,OSUSER
from gv$session  b  
where  wait_class<>'Idle' and blocking_session is not null and EVENT<>'enq: TM - contention'
order by blocking_session
/
 PORTAL_KPI_FHQXII 
select sid,inst_id,PROGRAM from gv$session where username='SGTAT';
execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_66186',task_owner => 'SYS', replace => TRUE);

select/*+rule*/ * from v$lock where block=1;
set linesize 250
set pagesize 200
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
col sql_id format a20
select sid,serial#,p1,p2,WAIT_TIME,event, program,sql_id,username
from v$session  b  
where  wait_class<>'Idle' order by sql_id ;

6  180439284
 6   66706936
select *  from dba_extents where file_id=2136 and 1114210 between block_id and block_id+blocks-1;
2136    1114210
file 18, block 764194
set pagesize 9999
seet wra off
set linesize 150
select 'alter system kill session '''||s.sid||','||s.serial#||''' immediate;' from v$session s where s.wait_class<>'Idle' and  sql_id='&1';
spool off;
@/tmp/aaaaa.sql
select 'alter system kill session '''||s.sid||','||s.serial#||''' immediate;' from 
v$session s where s.wait_class<>'Idle' and  event='library cache lock';
library cache lock
set linesize 180
set wra off
set pagesize 200
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
select sid,serial#,WAIT_TIME,event,p1raw,p1,p2, program,sql_id ,COMMAND,username
from gv$session  b  
where  wait_class<>'Idle'  and event like 'enq: TX - row%' order by sql_id -- and username='SYS'
and sid='8471'
 and username='SYS'
/
select sql_fulltext from v$sqlarea where SQL_ID='1dyqva6gys3yy';
set long 9999
set linesize 150
set wra on
select sql_fulltext from v$sqlarea where SQL_ID='&1';
select spid from v$process where addr=(select paddr from v$session where sid=&1)

set linesize 999
set wra on
set long 99999
set linesize 200
select sql_fulltext from v$sqlarea where sql_id='&1';
select 'select sql_text from v$sqlarea where sql_id='''||sql_id||''';' from v$session where wait_class<>'Idle' order by sql_id ;
select sql_id from gv$session  where sid='&1';

 SELECT/*+rule*/ inst_id,DECODE(request,0,'Holder: ','Waiter: ')||sid sess, 
         id1, id2, lmode, request, type
    FROM gV$LOCK
   WHERE (id1,type) IN
             (SELECT id1,type FROM V$LOCK WHERE request>0) 
   ORDER BY id1, request,INST_ID
  ;
  
  SELECT/*+rule*/ inst_id,DECODE(request,0,'Holder: ','Waiter: ')||sid sess, 
         id1, id2, lmode, request, type
    FROM gV$LOCK
   WHERE (id1,type) IN
             (SELECT id1,type FROM V$LOCK WHERE request>0) 
   ORDER BY sess
  ;
 
 
  create index CACHE01.IDX$$_2B43C0001 on CACHE01.E_CAT_PRC("PARA_VN","CAT_PRC_ID","PRC_CODE");
select sql_id,count(*) from v$session group by sql_id order by count(*);
exec DBMS_WORKLOAD_REPOSITORY.CREATE_SNAPSHOT();


select s.sid,s.username,sql_fulltext  from v$process p,v$session s ,v$sqlarea l where p.addr=s.paddr 
and s.sql_hash_value=l.hash_value and  wait_class<>'Idle';
SELECT t0.DATA_DATE, t0.DATAITEM_ID, t0.ID, t0.RESULT FROM hneic.E_MPED_DAY_FLAG t0 
WHERE t0.DATA_DATE =trunc(sysdate-7) AND t0.DATAITEM_ID = '30202001' AND t0.ID = '6125'

select sql_text from v$sql where sql_id in(select sql_id from v$session where machine='localhost.localdomain' and sql_id is not null);

select sql_id,count(*),event from v$session where  sql_id is not null  group by sql_id,event order by count(*)

select count(*) from v$session where machine='localhost.localdomain' and sql_id is not null 
select count(*) from v$session where machine='localhost.localdomain' and sql_id is not null 
select count(*),sql_id from v$session where  wait_class<>'Idle' group by sql_id order by count(*);
select count(*),sql_id from v$session where  wait_class<>'Idle' group by sql_id order by sql_id;


set linesize 250
set pagesize 200
col event format a30
col sid format 999999
col program format a30
col p2,p3 format 999999
col sql_id format a20
select sid,serial#,p1,p2,WAIT_TIME,event, program,sql_id,username
from v$session  b  
where  wait_class<>'Idle';
select 'alter system kill session '''||s.sid||','||s.serial#||''' immediate;' from 
v$session s where s.wait_class<>'Idle' and sql_id='&1';
ay4v7brp168tt
6xgxs5chy5h13
select sid,serial# from session where  sql_id='5kmwx0tydsqnu'
6x0upagzrf26b          5
1f35a7ru0g2yd          5
3wnb7vx1g7at6          
select sql_text from v$sqlarea where sql_id='&1';
select sql_id,count(*) from gv$session where wait_class<>'Idle'  group by sql_id order by count(*);

select  LAST_ANALYZED,table_name from dba_tables where owner='SGPMS' AND LAST_ANALYZED=SYSDATE-1

select 'exec dbms_stats.GATHER_TABLE_STATS(''DUNS'','''||table_name ||''',estimate_percent=>10,degree=>8 );' 
from dba_tables where owner='DUNS' and table_name='';
and ( LAST_ANALYZED is null or LAST_ANALYZED < to_date('2005-09-11','YYYY-MM-DD') )

select 'exec dbms_stats.GATHER_INDEX_STATS(''DUNS'','''||index_name ||''',estimate_percent=>10,degree=>8 );', 
from dba_indexes where owner='SGPMS'  and table_name='&1';
and ( LAST_ANALYZED is null or LAST_ANALYZED < to_date('2005-09-11','YYYY-MM-DD') )
set wra on
set linesize 140
set long 99999
select sql_fulltext from v$sql where sql_id='&1';

./cluvfy stage -pre crsinst -n upm-db1 -r 11gr2 -verbose
select 'alter system kill session '''||s.sid||','||s.serial#||''';' from 
v$session S WHERE machine='localhost.localdomain' and sql_id is not null

select 'alter system kill session '''||s.sid||','||s.serial#||''';' from 
v$session s,v$sqlarea l 
where  l.hash_value=s.sql_hash_value and s.wait_class<>'Idle' and sql_text like 'DELETE FROM MW_SYS.MWT_WF_TRSI%';

select 'alter system kill session '''||s.sid||','||s.serial#||''';' from 
v$session s,v$sqlarea l 
where  l.hash_value=s.sql_hash_value and s.wait_class<>'Idle' and sql_text like 'select atvi.atvi_id,atvi.atvi_sctime,(prcd.prcd_prior+prci.prci_prior) as%';

10.223.
临时表空间使用情况
Select 
'TEMPSPACE_FREE_RATIO' "TEMP_RATIO",
round(sum(round(((f.bytes_free + f.bytes_used) - nvl(p.bytes_used, 0)) / 1024 / 1024, 2))*100/sum(round((f.bytes_free + f.bytes_used) / 1024 / 1024, 2)),0) "temp_ratio"
from   SYS.V_$TEMP_SPACE_HEADER f, DBA_TEMP_FILES d, SYS.V_$TEMP_EXTENT_POOL p
where  f.tablespace_name(+) = d.tablespace_name
and    f.file_id(+) = d.file_id
and    p.file_id(+) = d.file_id
group by f.tablespace_name

Select 
d.tablespace_name,sum(round(f.bytes_free + f.bytes_used))/1024/1024,sum(p.bytes_used)/1024/1024,'TEMPSPACE_FREE_RATIO' "TEMP_FREERATIO",
round(sum(round(((f.bytes_free + f.bytes_used) - nvl(p.bytes_used, 0)) / 1024 / 1024, 2))*100/sum(round((f.bytes_free + f.bytes_used) / 1024 / 1024, 2)),0) "temp_freeratio"
from   SYS.V_$TEMP_SPACE_HEADER f, DBA_TEMP_FILES d, SYS.V_$TEMP_EXTENT_POOL p
where  f.tablespace_name(+) = d.tablespace_name
and    f.file_id(+) = d.file_id
and    p.file_id(+) = d.file_id
group by d.tablespace_name


create index sgpms.IDX_E_CONS_PRC_AMT1_no_ym on sgpms.E_CONS_PRC_AMT_1(cons_no,ym)  tablespace ywct parallel 8;
表碎片统计：

analyze table  PORTALPRODUCT.PORTAL_IMS_IDX  compute statistics；
select num_rows,TRUNC((num_rows*avg_row_len/8192)),trunc((TRUNC((num_rows*avg_row_len/8192))/blocks)*100),blocks,empty_blocks,table_name from dba_tables where 
 (num_rows*avg_row_len/8192)*1.3<blocks and blocks >=8000 and owner='PORTALPRODUCT' order by trunc((TRUNC((num_rows*avg_row_len/8192))/blocks)*100);


select count(*) from v$session where wait_class<>'Idle' and sql_id in(
select sql_id from v$sql where sql_text like 'select f.* from  e_mp_mon_demand f where f.data_date = to_date%')


select sql_text, 
select THREAD#,SEQUENCE#, FIRST_TIME from gv$log_history where FIRST_TIME >sysdate-1 and THREAD#=1 order by FIRST_TIME;


select sql_text from v$sql where sql_id='71v9276207466';

等待事情中sql语句：
7z11cfytagdy1
select  TEMP_SPACE_ALLOCATED,sql_id,SAMPLE_TIME  from dba_hist_active_sess_history  where sql_id='d19rfap5hud81'  
and 
SAMPLE_TIME>to_date('2019-05-01 12:00:00','yyyy-mm-dd hh24:mi:ss') and SAMPLE_TIME<to_date('2019-05-01 12:30:00','yyyy-mm-dd hh24:mi:ss')
group by event
order by count(*)

dba_hist_active_sess_history
select sid,serial#,p1,p2,WAIT_TIME,event, program,sql_id,username from dba_hist_active_sess_history  where sql_id='a13pw59pua2uw' and SAMPLE_TIME>to_date('2018-06-27 23:30:00','yyyy-mm-dd hh24:mi:ss')

select sql_text,buffer_gets,executions,event from dba_hist_active_sess_history a, gv$sql b where 
a.event='gc buffer busy' and a.snap_id>=4493 
and a.snap_id<=4494 and a.sql_id=b.sql_id

根据spid 查询sql语句。
col PROGRAM format a30
col MACHINE a20
set long 99999
set wra on
select s.sid,s.serial#,s.sql_id,s.PROGRAM,l.sql_fulltext  from v$process p,v$session s ,v$sqlarea l where p.addr=s.paddr 
and s.sql_hash_value=l.hash_value 
and spid='&1' ;

select s.sid,s.username,sql_fulltext  from v$process p,v$session s ,v$sql l where p.addr=s.paddr 
and s.sql_hash_value=l.hash_value 
and spid='684450' 

index 分析：
select 'analyze index hneic.'||index_name||' validate structure;' from dba_indexes where owner='HNEIC' AND NUM_ROWS>1000 order by NUM_ROWS;
analyze index hneic.CONS_NAME_INDX  validate structure;
select (del_lf_rows/lf_rows_len)*100 from index_stats where name='CONS_NAME_INDX';

数据词典分析
exec dbms_stats.gather_fixed_objects_stats
gkcf68mr94mry
等待事情分析：
dba_hist_active_sess_history

select/*+rule*/user_id,max(sample_time) from dba_hist_active_sess_history group by user_id

select SQL_EXEC_ID,SESSION_ID,count(*),min(sample_time),max(sample_time) 
from dba_hist_active_sess_history where  sql_id='3fctay67dv1p1' and to_char(sample_time,'yyyy-mm-dd')='2017-01-05' 
group by  SQL_EXEC_ID,SESSION_ID having count(*)>=0 order by min(sample_time)

col event format a40
select event,sum(WAIT_TIME) from dba_hist_active_sess_history where sql_id='05vnchx5akdut'
and SAMPLE_TIME>to_date('2018-04-24 08:00:00','yyyy-mm-dd hh24:mi:ss') group by event
ghjy2sqffdf88
select * from  dba_hist_snapshot where instance_number='1'

select wait_class_id,wait_class,count(*) cnt  from dba_hist_active_sess_history where snap_id 
between 418 and 421 group by wait_class_id,wait_class order by 3

3871361733
dba_hist_active_sess_history;
gc current block congested
dba_hist_active_sess_history
select sql_id,count(*) from dba_hist_active_sess_history 
where event='gc current block congested' 
and SAMPLE_TIME >to_date('2019-01-03 09:00','yyyy-mm-dd hh24:mi:ss') 
and SAMPLE_TIME <to_date('2019-01-03 11:00','yyyy-mm-dd hh24:mi:ss')
group by sql_id
order by count(*);

select SAMPLE_TIME from  dba_hist_active_sess_history where user_id='33';
select to_char(SAMPLE_TIME,'yyyy-mm-dd hh24'),count(*),event from dba_hist_active_sess_history 
where SAMPLE_TIME>to_date('2018-06-03 14:00:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2018-06-03 17:30:00','yyyy-mm-dd hh24:mi:ss')
group by to_char(SAMPLE_TIME,'yyyy-mm-dd hh24'),event order by to_char(SAMPLE_TIME,'yyyy-mm-dd hh24')

select ACTION,MODULE from dba_hist_active_sess_history  where 
SAMPLE_TIME>to_date('2018-06-03 14:00:00','yyyy-mm-dd hh24:mi:ss') and SAMPLE_TIME<to_date('2018-06-03 17:30:00','yyyy-mm-dd hh24:mi:ss')
group by ACTION,MODULE;

JS kill job wait
select SAMPLE_TIME from dba_hist_active_sess_history where event='JS kill job wait' and 
SAMPLE_TIME>to_date('2018-06-03 14:00:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2018-06-03 17:30:00','yyyy-mm-dd hh24:mi:ss')

select count(*),sql_id  from dba_hist_active_sess_history where SAMPLE_TIME>to_date('2019-04-15 08:00:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2019-04-15 08:20:00','yyyy-mm-dd hh24:mi:ss') and event='enq: TM - contention' group by sql_id  order by count(*)

select wait_class_id,wait_class,event,sql_id,count(*) cnt  from dba_hist_active_sess_history 
where SAMPLE_TIME>to_date('2018-11-25 10:25:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2018-11-25 10:30:00','yyyy-mm-dd hh24:mi:ss')
and instance_number='2' group by wait_class_id,wait_class,event,sql_id order by count(*)

select blocking_session,count(*)  from  dba_hist_active_sess_history  where event='gc buffer busy acquire'
and  SAMPLE_TIME>to_date('2018-04-30 09:30:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2018-04-30 11:00:00','yyyy-mm-dd hh24:mi:ss') group by blocking_session order by count(*)

select event,sql_id from dba_hist_active_sess_history  where event='gc buffer busy acquire'
and  SAMPLE_TIME>to_date('2018-04-30 09:30:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2018-04-30 11:00:00','yyyy-mm-dd hh24:mi:ss') and SESSION_ID='3091'
                                                                                                     403
   3871361733 Cluster              gc current request                                                  536
   3875070507 Concurrency          latch: cache buffers chains                                        1001
   3875070507 Concurrency          enq: TX - index contention                                         1072
   4217450380 Application          enq: TX - row lock contention                                      2476
   3871361733 Cluster              gc buffer busy release                                            13430
   3871361733 Cluster              gc buffer busy acquire                                           285396
1740759767
Cmo-.830

select wait_class_id,wait_class,count(*) cnt  from dba_hist_active_sess_history 
where SAMPLE_TIME>to_date('2019-04-02 12:15:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2019-04-02 12:18:00','yyyy-mm-dd hh24:mi:ss')
and instance_number='1' group by wait_class_id,wait_class order by 3
 select sql_text from dba_hist_sqltext where sql_id='&1';
 
select event_id,event,count(*) from dba_hist_active_sess_history 
where SAMPLE_TIME>to_date('2019-04-02 12:25:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2019-04-02 12:30:00','yyyy-mm-dd hh24:mi:ss')
and instance_number='1'
and wait_class_id=3875070507  group by event_id,event order by 3

select sql_id,count(*) from dba_hist_active_sess_history where event='cursor: pin S wait on X' and 
SAMPLE_TIME>to_date('2018-06-13 08:30:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2018-06-13 09:00:00','yyyy-mm-dd hh24:mi:ss') group by sql_id

dba_hist_sql_plan
set linesize 500
set pagesize 500
col plan_hash_value format 9999999999
col id format 999999
col operation format a30
col options format a15
col object_owner format a15
col object_name format a20
col optimizer format a15
col cost format 9999999999
col access_predicates format a15
col filter_predicates format a15
SELECT plan_hash_value,TIMESTAMP,
         id,
         LPAD (' ', DEPTH) || operation operation,
         options,
         object_owner,
         object_name,
         optimizer,
         cost,
         access_predicates,
         filter_predicates
FROM dba_hist_sql_plan
WHERE sql_id = '&1'
ORDER BY plan_hash_value, id;


select TIMESTAMP,plan_hash_value from  dba_hist_sql_plan where sql_id='05vnchx5akdut';

select event_id,event,count(*)  from dba_hist_active_sess_history where SAMPLE_TIME>to_date('2016-12-21 16:32:00','yyyy-mm-dd hh24:mi:ss') and SAMPLE_TIME<to_date('2016-12-21 16:33:00','yyyy-mm-dd hh24:mi:ss') and instance_number='1'  and wait_class_id=4108307767 group by event_id,event order by 3

select sql_id,count(*) cnt from dba_hist_active_sess_history  
where SAMPLE_TIME>to_date('2017-09-26 10:58:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2017-09-26 11:00:00','yyyy-mm-dd hh24:mi:ss')
and instance_number='2'
and event_id in(2652584166) group by sql_id 


having count(*)>10 order by count(*)

select sql_id,count(*)  from dba_hist_active_sess_history 
where 
SAMPLE_TIME>to_date('2016-12-21 16:32:00','yyyy-mm-dd hh24:mi:ss') 
and SAMPLE_TIME<to_date('2016-12-21 16:33:00','yyyy-mm-dd hh24:mi:ss') and instance_number='1'  
and  event_id in(2652584166) group by sql_id order by count(*)


dba_hist_active_sess_history 
select count(*),to_char(sample_time,'yyyy-mm-dd hh24:mi'),INSTANCE_NUMBER from dba_hist_active_sess_history
where sample_time>sysdate-1 and sql_id='0v17nh992bvyd' group by to_char(sample_time,'yyyy-mm-dd hh24:mi'),INSTANCE_NUMBER
order by 2

select sql_id,sql_fulltext from v$sql where
sql_id
in(
select sql_id from dba_hist_active_sess_history  where snap_id 
between 60316 and 60319 and event_id in(589947255) group by sql_id 
having count(*)>5
)

select INSTANCE_NUMBER,EVENT,a.sql_id,DISK_READS,BUFFER_GETS,executions,buffer_gets/executions,b.sql_text from dba_hist_active_sess_history a,gv$sqlarea b
where SAMPLE_TIME>to_date('2016-09-09 10:00:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2016-09-05 10:13:00','yyyy-mm-dd hh24:mi:ss')  and INSTANCE_NUMBER=4 and  BUFFER_GETS>1000000
and a.sql_id=b.sql_id order by buffer_gets/executions

select sql_id,count(*),sum(TM_DELTA_CPU_TIME)/1000/1000   from dba_hist_active_sess_history 
where SAMPLE_TIME>to_date('2016-09-21 09:10:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2016-09-21 09:20:00','yyyy-mm-dd hh24:mi:ss') and INSTANCE_NUMBER=3 
group by sql_id order by sum(TM_DELTA_CPU_TIME)

select sql_id,machine,count(*),sum(TM_DELTA_CPU_TIME)/1000000   from dba_hist_active_sess_history 
where SAMPLE_TIME>to_date('2016-09-10 11:00:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2016-09-10 11:01:00','yyyy-mm-dd hh24:mi:ss') and INSTANCE_NUMBER=&1 
and sql_id is not null
group by rollup(sql_id,machine) order by sum(TM_DELTA_CPU_TIME)/1000000

select sql_id,count(*),sum(TM_DELTA_CPU_TIME)/1000   from dba_hist_active_sess_history 
where SAMPLE_TIME>to_date('2016-09-09 09:29:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2016-09-09 09:33:00','yyyy-mm-dd hh24:mi:ss') and INSTANCE_NUMBER=3 
and sql_id is not null
group by rollup(sql_id) order by sum(TM_DELTA_CPU_TIME)/1000
12481
libcache interrupt action by LCK
set wra off
select  sql_id,BLOCKING_SESSION,BLOCKING_SESSION_SERIAL# from dba_hist_active_sess_history  where SAMPLE_TIME>to_date('2019-04-18 11:00:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2019-04-18 11:30:00','yyyy-mm-dd hh24:mi:ss') and event='enq: TX - index contention'  and sql_id='5jtbcywmg7zxj'

select  event,count(*) from dba_hist_active_sess_history  where SAMPLE_TIME>to_date('2019-04-18 08:00:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2019-04-18 12:00:00','yyyy-mm-dd hh24:mi:ss')  and sql_id='5jtbcywmg7zxj' group by event order by count(*);


select * from dba_hist_active_sess_history  where   SESSION_ID='16052';
update C_PS set CONS_ID=:1 where CONS_ID=:2
select event,sql_id,SAMPLE_TIME from dba_hist_active_sess_history  where SAMPLE_TIME>to_date('2016-08-13 22:00:00','yyyy-mm-dd hh24:mi:ss') and SAMPLE_TIME<to_date('2016-08-13 23:07:00','yyyy-mm-dd hh24:mi:ss') and event='libcache interrupt action by LCK';
查询执行计划：
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('5kk6khzd8jun5'));

select owner from dba_tables where table_name='A_PC_TRAN_UNBAL';
查询share_pool_reserved
select used_space, requests, request_misses, last_miss_sizefrom v$shared_pool_reserved /

分析x 表
DBMS_STATS.GATHER_FIXED_OBJECTS_STATS

SQL> insert into i6000_yydsj.yydsj_active_user(APPLICATION_ID,APPLICATION_NAME,PROVINCE_ID,PROVINCE_NAME,SHOW_DATE) values('111','2222','yydsj0112','4444','2018-01-01');

set linesize 180    
set pages 999
 set long 90000     

查看创建用户表的SQL 
i6000_yydsj.yydsj_active_user

查看当前用户表的SQL 
select dbms_metadata.get_ddl('INDEX','I_SNAP$_SYS_V_USERROLEORGR','I6000_SYS') from dual; 
GWDLDXPT.TD_SMSS_SEND_SYSTEM_DONE
SCYW.T_SB_ECSB_JLBHZZ_VER
IND_PUB_E_PQ_AMT_CONSNO_YM
查看其他用表或索引的SQL 
set linesize 180    
set pages 999
set long 90000     
SELECT DBMS_METADATA.GET_DDL('TABLE','T_YJ_DWYJ_JXJH','PMS') FROM DUAL; 
set linesize 180    
set pages 999
set long 90000 
select dbms_metadata.get_ddl('INDEX','I_PROVINCE_SEND_LOG_SENDDATE','DXP') from dual; 

set long 9999
set wra on
set linesize 120
set pagesize 9999
SELECT DBMS_METADATA.GET_DDL('SEQUENCE','SEQ_F_YPGT_COMPLETE_STAT ','SGPMS') FROM DUAL; 

select /*+rule*/ sql_text from gv$transaction t,gv$session s,gv$sql l where t.addr=s.taddr and s.sql_id=l.sql_id and to_date(START_TIME,'mm/dd/yy hh24:mi:ss')<sysdate-2/48

select addr, START_TIME from gv$transaction order by START_TIME

select sql_id from gv$session s,gv$lock l where l.block=1 and s.sid=l.sid;


SELECT a.tablespace_name, sum(a.free_mb),sum(b.size_mb),sum(b.size_mb-a.free_mb),sum(Trunc((a.free_mb/b.size_mb) * 100)) "FREE_%" FROM   
(SELECT  tablespace_name, Trunc(Sum(bytes)/1024/1024) free_mb      FROM   dba_free_space  where tablespace_name in('EOM_STATS_2016','EOM_STATS','EOM','EOM_IDX','EOM_LOG','EOM_LOG_IDX_2016') GROUP BY tablespace_name ) a,       
(SELECT tablespace_name,  Trunc(Sum(bytes)/1024/1024) size_mb      FROM   dba_data_files where tablespace_name in('EOM_STATS_2016','EOM_STATS','EOM','EOM_IDX','EOM_LOG','EOM_LOG_IDX_2016') GROUP BY tablespace_name ) b 
WHERE  a.tablespace_name = b.tablespace_name  group by a.tablespace_name  order by sum(Trunc((a.free_mb/b.size_mb) * 100));


 SELECT a.tablespace_name, a.free_mb,b.size_mb,Trunc((a.free_mb/b.size_mb) * 100) "FREE_%" FROM   
 (SELECT tablespace_name,Trunc(Sum(bytes)/1024/1024) free_mb      FROM   dba_free_space         GROUP BY tablespace_name) a,       
 (SELECT tablespace_name,  Trunc(Sum(bytes)/1024/1024) size_mb   FROM   dba_data_files GROUP BY tablespace_name) b 
 WHERE  a.tablespace_name = b.tablespace_name 
 order by b.size_mb 
 

create table user_table (dt date,name varchar2(20),free varchar2(20),total varchar2(20));
drop table user_table;

create table user_table (dt date,name varchar2(20),free varchar2(20),total varchar2(20),ratio varchar2(20));
insert into user_table
SELECT  sysdate,a.tablespace_name, trunc(b.size_mb-a.free_mb),b.size_mb,Trunc((a.free_mb/b.size_mb) * 100) "FREE_%" FROM   (SELECT tablespace_name, 
Trunc(Sum(bytes)/1024/1024) free_mb      FROM   dba_free_space       GROUP BY tablespace_name) a,       
 (SELECT tablespace_name,  Trunc(Sum(bytes)/1024/1024) size_mb         
 FROM   dba_data_files       
 GROUP BY tablespace_name) b WHERE  a.tablespace_name = b.tablespace_name order by trunc(b.size_mb-a.free_mb)
 commit;

create table user_seg(space varchar2(20),name varchar2(20),owner varchar2(20));
insert into user_seg
select /*+rule*/ sum(bytes)/1024/1024,segment_name,owner 
from dba_segments where tablespace_name='USERS'
group by segment_name,owner  
having sum(bytes)/1024/1024>1 order by sum(bytes)/1024/1024;
commit;

 
 
 自动扩张:
 SELECT a.tablespace_name,
       b.max_size_kb - (b.size_kb - a.free_kb) free_kb,
       Trunc(((b.max_size_kb - (b.size_kb - a.free_kb)) / (b.max_size_kb)) * 100) "FREE_%"
  FROM (SELECT tablespace_name, Trunc(Sum(bytes) / 1024) free_kb
          FROM dba_free_space where tablespace_name='USERS'
         GROUP BY tablespace_name) a,
       (SELECT tablespace_name,
         Trunc(Sum(decode(AUTOEXTENSIBLE, 'NO', bytes, 'YES', case when MAXBYTES<=bytes then bytes else MAXBYTES end )) / 1024) max_size_kb,
               trunc(sum(bytes) / 1024) size_kb
          FROM dba_data_files where tablespace_name='USERS'
         GROUP BY tablespace_name) b
 WHERE a.tablespace_name = b.tablespace_name
 order by Trunc(((b.max_size_kb - (b.size_kb - a.free_kb)) /(b.max_size_kb)) * 100)
 
 SELECT a.tablespace_name,
       b.max_size_kb - (b.size_kb - a.free_kb) free_kb, b.max_size_kb,
       Trunc(((b.max_size_kb - (b.size_kb - a.free_kb)) / (b.max_size_kb)) * 100) "FREE_%"
  FROM (SELECT tablespace_name, Trunc(Sum(bytes) / 1024) free_kb
          FROM dba_free_space 
         GROUP BY tablespace_name) a,
       (SELECT tablespace_name,
         Trunc(Sum(decode(AUTOEXTENSIBLE, 'NO', bytes, 'YES', case when MAXBYTES<=bytes then bytes else MAXBYTES end )) / 1024) max_size_kb,
               trunc(sum(bytes) / 1024) size_kb
          FROM dba_data_files 
         GROUP BY tablespace_name) b
 WHERE a.tablespace_name = b.tablespace_name
 order by Trunc(((b.max_size_kb - (b.size_kb - a.free_kb)) /(b.max_size_kb)) * 100)

alter tablespace USR_CUS_TBS add datafile '/dev/vgyxbb11/rlv1091' size 16000M autoextend off;

数据文件收缩防范 resize:
col file_name format a50
set linesize 150
set wra off
set pagesize 1000
select 'alter database datafile '||a.file_id||' resize 20G;' from 
(select * from dba_data_files where file_name like '+DATA%' )a,
(select sum(bytes) bytes,file_id from dba_free_space group by file_id) b 
where a.file_id=b.file_id and trunc((b.bytes/a.bytes)*100)>40
and a.bytes>30*1024*1024*1024 and a.tablespace_name
 in(
 SELECT a.tablespace_name FROM   
 (SELECT tablespace_name, Trunc(Sum(bytes)/1024/1024) free_mb FROM dba_free_space GROUP BY tablespace_name) a,       
 (SELECT tablespace_name,  Trunc(Sum(bytes)/1024/1024) size_mb FROM dba_data_files   where file_name like '+DATA%' 
  GROUP BY tablespace_name) b 
 WHERE  a.tablespace_name = b.tablespace_name
 and Trunc((a.free_mb/b.size_mb) * 100) >40 and b.size_mb>30000)
 
 CACHE_SC_DATA                                                                                   97871      98301         99
CACHE_SC_IDX                                                                                    98298      98301         99
SHARE_PT3_IDX                                                                                   98130      98303         99
SHARE_PT4_IDX                                                                                  100180     100351         99
SHARE_PT2_IDX                                                                                  121682     121855         99
SHARE_PT1_IDX                                                                                  145531     145663         99
-----------------------
单个文件使用率：
col file_name format a50
set linesize 150
set wra off
select 'alter database datafile '||a.file_id||' resize 10G;' from dba_data_files a,
(select sum(bytes) bytes,file_id from dba_free_space where TABLESPACE_NAME 
in('CACHE_FK_DATA','UNDOTBS2','SHARE_PT3_IDX','SHARE_PT4_IDX','SHARE_PT2_IDX','SHARE_PT1_IDX')
 group by file_id) b 
where a.file_id=b.file_id and trunc((b.bytes/a.bytes)*100)>70 
and a.bytes>25*1024*1024*1024
order by trunc((b.bytes/a.bytes)*100) desc
and trunc(a.bytes/b.bytes)>1
归档信息查询：
col aa format a40
select to_char(FIRST_TIME,'yyyy-mm-dd hh24') aa,count(*) from v$log_history  where FIRST_TIME>sysdate-40
--and thread#=1  
group by to_char(FIRST_TIME,'yyyy-mm-dd hh24')
order by to_char(FIRST_TIME,'yyyy-mm-dd hh24');

select to_char(FIRST_TIME,'yyyy-mm-dd') aa,count(*) from v$log_history  where FIRST_TIME>sysdate-30   group by to_char(FIRST_TIME,'yyyy-mm-dd')
order by to_char(FIRST_TIME,'yyyy-mm-dd');

select to_char(FIRST_TIME,'yyyy-mm-dd hh24') aa,count(*),thread# from v$log_history  where FIRST_TIME>sysdate-30   group by to_char(FIRST_TIME,'yyyy-mm-dd hh24'),thread#
order by to_char(FIRST_TIME,'yyyy-mm-dd hh24');


select to_char(FIRST_TIME,'yyyy-mm-dd hh24:mi'),count(*) from gv$log_history  where FIRST_TIME>sysdate-5  group by to_char(FIRST_TIME,'yyyy-mm-dd hh24:mi')  
order by to_char(FIRST_TIME,'yyyy-mm-dd hh24:mi');
select to_char(FIRST_TIME,'yyyy-mm-dd hh24'),count(*) from gv$log_history  where FIRST_TIME>sysdate-10 group by to_char(FIRST_TIME,'yyyy-mm-dd hh24')  
order by to_char(FIRST_TIME,'yyyy-mm-dd hh24');
select to_char(FIRST_TIME,'yyyy-mm-dd'),count(*) from gv$log_history  where THREAD#=1   group by to_char(FIRST_TIME,'yyyy-mm-dd')  order by to_char(FIRST_TIME,'yyyy-mm-dd')
select to_char(FIRST_TIME,'yyyy-mm-dd'),count(*) from v$log_history    group by to_char(FIRST_TIME,'yyyy-mm-dd')  order by to_char(FIRST_TIME,'yyyy-mm-dd')
 
 gv$archived_history
select to_char(FIRST_TIME,'yyyy-mm-dd'),count(*) from v$log_history   group by to_char(FIRST_TIME,'yyyy-mm-dd')  order by to_char(FIRST_TIME,'yyyy-mm-dd')

select to_char(FIRST_TIME,'yyyy-mm-dd'),count(*) from gv$log_history where thread#=1  group by to_char(FIRST_TIME,'yyyy-mm-dd')  
order by to_char(FIRST_TIME,'yyyy-mm-dd');


select to_char(COMPLETION_TIME,'yyyy-mm-dd'),count(*) from v$archived_log   group by to_char(COMPLETION_TIME,'yyyy-mm-dd')  
order by to_char(COMPLETION_TIME,'yyyy-mm-dd');
select to_char(FIRST_TIME,'yyyy-mm-dd'),count(*) from gv$log_history  group by to_char(FIRST_TIME,'yyyy-mm-dd')  
order by to_char(FIRST_TIME,'yyyy-mm-dd');

select to_char(FIRST_TIME,'yyyy-mm-dd hh24'),count(*) from v$log_history  where FIRST_TIME>sysdate-30  group by to_char(FIRST_TIME,'yyyy-mm-dd hh24')
order by to_char(FIRST_TIME,'yyyy-mm-dd hh24');


select to_char(FIRST_TIME,'yyyy-mm-dd hh24'),count(*) from gv$log_history where thread#=1 and FIRST_TIME>sysdate-20 group by to_char(FIRST_TIME,'yyyy-mm-dd hh24')  
having count(*) >25 order by count(*)
order by to_char(FIRST_TIME,'yyyy-mm-dd hh24') having count(*) >20
select to_char(FIRST_TIME,'yyyy-mm-dd'),count(*) from v$log_history   group by to_char(FIRST_TIME,'yyyy-mm-dd')  
order by to_char(FIRST_TIME,'yyyy-mm-dd');

select thread#,to_char(FIRST_TIME,'yyyy-mm-dd'),count(*) from gv$log_history 
where 
to_char(FIRST_TIME,'hh24')>=10 and to_char(FIRST_TIME,'hh24')<11
group by thread#,to_char(FIRST_TIME,'yyyy-mm-dd')
order by to_char(FIRST_TIME,'yyyy-mm-dd')
select to_char(FIRST_TIME,'yyyy-mm-dd hh24:mi:ss'),RECID,THREAD# from v$log_history where FIRST_TIME  >sysdate-1
order by THREAD#,FIRST_TIME 

select to_char(FIRST_TIME,'yyyy-mm-dd hh24'),count(*) from gv$log_history  where FIRST_TIME>sysdate-30  group by to_char(FIRST_TIME,'yyyy-mm-dd hh24') 
order by to_char(FIRST_TIME,'yyyy-mm-dd hh24');

修改local_listener remote_listener
alter system set local_listener='(address=(protocol=tcp)(host=pmhnrdb2)(port=11521))' sid='
(address=(protocol=tcp)(host=pmhnrdb1)(port=21521))
alter system set local_listener='(address=(protocol=tcp)(host=yxjs-test1)(port=21521))' sid='imscm1'
alter system set local_listener='(address=(protocol=tcp)(host=10.223.4.105)(port=1521))' sid='imscm2'
alter system set local_listener='(address=(protocol=tcp)(host=10.223.3.6)(port=3521))' sid='repdb2';
alter system set remote_listener='(address=(protocol=tcp)(host=10.223.3.8)(port=3521))' sid='repdb1';
alter system set remote_listener='(address=(protocol=tcp)(host=10.223.3.7)(port=3521))' sid='repdb2';
mv adump adump.bak
mkdir adump
rm -rf adump

alter system set local_listener='(address=(protocol=tcp)(host=pmsdb1)(port=11521))' 
添加删除日志组
alter database add logfile thread 2 group 5('/dev/vgyxbb05/rlv1g_09') size 1000m;
alter database add logfile member '/dev/vgyxbb05/rlv1g_10' to group 5;

alter database add logfile member '+PMDBDATA1' to group 1;
alter database add logfile member '+PMDBDATA1' to group 2;
alter database add logfile member '+PMDBDATA1' to group 3;
alter database add logfile member '+PMDBDATA1' to group 4;
alter database add logfile member '+PMDBDATA1' to group 5;
alter database add logfile member '+PMDBDATA1' to group 6;
alter database add logfile member '+PMDBDATA1' to group 7;
alter database add logfile member '+PMDBDATA1' to group 8;
alter database add logfile member '+PMDBDATA1' to group 9;
alter database add logfile member '+PMDBDATA1' to group 10;
alter database add logfile member '+PMDBDATA1' to group 11;
alter database add logfile member '+PMDBDATA1' to group 12;
alter database add logfile member '+PMDBDATA1' to group 13;
alter database add logfile member '+PMDBDATA1' to group 14;
alter database add logfile member '+PMDBDATA1' to group 15;
alter database add logfile member '+PMDBDATA1' to group 16;
alter database add logfile member '+PMDBDATA1' to group 17;
alter database add logfile member '+PMDBDATA1' to group 18;
alter database add logfile member '+PMDBDATA1' to group 19;
alter database add logfile member '+PMDBDATA1' to group 20;
alter database add logfile member '+PMDBDATA1' to group 21;
alter database add logfile member '+PMDBDATA1' to group 22;
alter database add logfile member '+PMDBDATA1' to group 23;
alter database add logfile member '+PMDBDATA1' to group 24;

alter database add logfile member '+PMDBDATA1' size 2147483648 to group 2;

alter database add logfile thread 1 group 9('+DATA') size 1G;
alter database add logfile thread 1 group 10('+DATA') size 1G;
alter database add logfile thread 1 group 11('+DATA') size 1G;
alter database add logfile thread 2 group 12('+DATA') size 1G;
alter database add logfile thread 2 group 13('+DATA') size 1G;
alter database add logfile thread 2 group 14('+DATA') size 1G;

alter database add logfile thread 1 group 5('+data') size 1048576000;

alter database add logfile thread 1 group 11('/oradata2/redo11') size 4G;
alter database add logfile thread 1 group 12('/oradata2/redo12') size 4G;
alter database add logfile thread 1 group 13('/oradata2/redo13') size 4G;
alter database add logfile thread 1 group 14('/oradata2/redo14') size 4G;
alter database add logfile thread 1 group 15('/oradata2/redo15') size 4G;
alter database add logfile thread 1 group 16('/oradata2/redo16') size 4G;

alter system checkpoint;
alter system switch logfile;
alter database drop logfile group 2;
alter database add logfile thread 2 group 12('/dev/vgyxbb01/rlv_redo12') size 1048576000;
alter database add logfile thread 1 group 6('+data') size 1000m;
alter database add logfile thread 1 group 7('+data') size 1000m;
alter database add logfile thread 1 group 8('+data') size 1000m;

alter database drop logfile member '+NEWREDO/pmdba/onlinelog/group_1.256.960949233' ;

alter database add logfile thread 2 group 9('+data') size 1000m;
alter database add logfile thread 2 group 10('+data') size 1000m;
alter database add logfile thread 2 group 11('+data') size 1000m;
alter database add logfile thread 2 group 12('+data') size 1000m;

删除物化视图
drop materialized view log on UPM_V2.USER_RES_R_EXT_VIEW;
drop materialized view UPM_V2.USER_RES_R_EXT_VIEW;
删除表空间
drop tablespace TBS_PTN_IDX   including contents and datafiles ;
'(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=10.232.1.10)(PORT=1526))))' sid='UPM1';
 (ADDRESS=(PROTOCOL=TCP)(HOST=10.232.1.10)(PROT=1526))
 
select a.ksppinm name, b.ksppstvl value, a.ksppdesc description
  from x$ksppi a, x$ksppcv b
 where a.indx = b.indx and a.ksppinm like '_smu_debug_mode';
_asm_hbeatiowait                         15

alter system set "_asm_hbeatiowait"=200 scope=spfile;


alter system set local_listener ='(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=10.223.2.243)(PORT=11521))))' sid='i60001';
alter system set local_listener ='(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=10.223.2.245)(PORT=11521))))' sid='i60002';

local_listener                       string      (DESCRIPTION=(ADDRESS=(PROTOCO                                                 L=tcp)(HOST=10.223.2.244)(PORT
                                                 =11521)))
alter system set local_listener ='(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=10.223.4.148)(PORT=3521))))' sid='+ASM2';

alter system set local_listener ='(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=10.223.4.148)(PORT=3521))))' sid='pms2hn2';

+DGODS/ods/datafile/ods_hrads.dbf                          17 ODS_HRADS
alter tablespace ODS_HRADS add datafile '+DGODS/ods/datafile/ods_hrads01.dbf' size 10g autoextend off;
./cluvfy stage -pre crsinst -n upm-db1 -r 11gr2 -verbose

select substr(sql_text,1,80) ,count(*) from v$sqlarea group by substr(sql_text,1,80) having count(*)>100 order by count(*)
lsvg vgname 
lslv lvname
lsvg -l vgname 
mklv -y  undo03 -t jfs2  rac_datavg 40;
mklv -y  undo04 -t jfs2  rac_datavg 40;
chown oracle:oinstall /dev/rundo03
chown oracle:oinstall /dev/rundo04
chown 660 /dev/rundo03
chown 660 /dev/rundo04
create undo tablespace undotbs3 datafile '/dev/rundo03' size 20000M autoextend off;
create undo tablespace undotbs4 datafile '/dev/rundo04' size 20000M autoextend off;
mkpv
mkvg
select spid from v$process where addr=(select paddr from v$session where sid=&1)
set wra off
set linesize 140
col file_name format a50
select * from dba_data_files order by  file_name
where tablespace_name='USR_ACC_TBS';
USR_CUS_TBS、USR_ACC_TBS、USR_PTB_TBS、USR_PTC_TBS
alter database datafile '+DATA/znsfmid/datafile/usr_acc_tbs_01' resize 1000m;
alter tablespace USR_ACC_TBS add datafile 
 '/dev/vgdlyx07/rlv0728' size 16000M autoextend off,
 '/dev/vgdlyx07/rlv0729' size 16000M autoextend off,
 '/dev/vgdlyx07/rlv0730' size 16000M autoextend off;
 
 select sql_text from v$sql where sql_id='&1';
 
 0c1fvf8afpk2z
 set wra on
 set linesize 9999
 set long 9999
 SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('&1'));
 <input type="radio" name=" select spid from v$process where addr=(select paddr from v$session where sid=&1)" value="">
   select spid from v$process where addr in (select paddr from v$session where sid in(select sid from v$lock where type='TX'));
   
   
select spid from v$process where addr in (select paddr from v$session where sid in(select sid from 
v$session where EVENT='read by other session'));
select * from 

exec DBMS_WORKLOAD_REPOSITORY.CREATE_SNAPSHOT();

select * from dba_segments where tablespace_name='SYSAUX' and segment_name=upper('wrh$_active_session_history');

wrh$_active_session_history

select * from pending_trans$
select * from dba_2pc_neighbors;

BEGIN PR_GET_FUNDPAYMENT_DATA(:1, :2, :3, :4, :5, :6, :7, :8, :9); END;
set long 999999
set linesize 150
set pagesize 9999
select text from dba_source  where name='PR_GET_FUNDPAYMENT_DATA';

9ud37777jvkvw



语句1：
SELECT TYPEID, PZLX, KMID, DFKMID, XDFS FROM ZWPZXD WHERE PZLX=:1 AND COMPID=:2
SELECT TYPEID,PZLX,KMID,DFKMID,XDFS FROM ZWPZXD WHERE PZLX=:1 AND
COMPID=:2

Plan hash value: 943368654

----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |       |       |  1042 (100)|          |
|*  1 |  TABLE ACCESS FULL| ZWPZXD |    11 |   231 |  1042   (3)| 00:00:15 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter(("COMPID"=:2 AND "PZLX"=:1))


DBMS_SQLTUNE包使用
var  my_recomm   CLOB;
DECLARE
my_task_name VARCHAR2(30);
BEGIN
my_task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK( sql_id    => '6b9cmcdd036bz' );
DBMS_SQLTUNE.EXECUTE_TUNING_TASK( task_name => my_task_name );
select DBMS_SQLTUNE.REPORT_TUNING_TASK( my_task_name ) into :my_recomm from dual;
END;
/

print :my_recomm

set newname for datafile 4 to '/oradata/pmdba/rlv1080_10g';
set pagesize 9999
set lindsize 150
set wra off
select 'set newname for datafile '||file#||' to '''||replace(name,'/dev','/oradata/pmdba')||''';' 
from v$datafile;


select 'set newname for tempfile '||file#||' to '''||replace(name,'/dev','/oradata/pmdba')||''';' 
from v$tempfile;


碎片整理：
查看碎片程度高的表
SELECT segment_name table_name , COUNT(*) extents
FROM dba_segments WHERE owner NOT IN ( 'SYSTEM') GROUP BY segment_name
HAVING COUNT(*) = (SELECT MAX( COUNT(*) ) FROM dba_segments GROUP BY segment_name);

select num_rows,owner,TRUNC((num_rows*avg_row_len/8192)),blocks,empty_blocks,table_name from dba_tables where 
 (num_rows*avg_row_len/8192)*1.3<blocks and blocks >=8000 and owner like '%_APP';
 
set linesize 150
col  avg_blocks format 99999999
col 
select num_rows,owner,TRUNC((num_rows*avg_row_len/8192)) avg_blocks,blocks,empty_blocks,table_name from dba_tables where 
(num_rows*avg_row_len/8192)*1.2<blocks and blocks >=8000 order by blocks

select segment_name,owner,sum(bytes)/1024/1024/1024 from dba_segments having sum(bytes)/1024/1024>10 group by segment_name,owner
order by sum(bytes)/1024/1024/1024
检查碎片最多的对象

col OWNER format a10
col TABLESPACE format a20
col SEGMENT_TYPE format a10 
col SEGMENT_NAME format a30
set pagesize 9999
select * from 
(
select owner,tablespace_name, segment_type,segment_name,extents, round((bytes)/1024/1024,2) as "Seg Sz(M)",
round(next_extent/1024/1024,2) as "Next Ext (M)", round((bytes/extents)/1024/1024,2) as "Avg Ext (M)" 
from dba_segments 
WHERE owner not in('SYSTEM','OUTLN','STAGE','TARGET')
and max_extents>0 
order by 5 desc, 8 asc
) 
where rownum<=50
/

检查表空间碎片的管理情况
select 
 total.tablespace_name as "Tablespace Name", 
 count(free.bytes) as "# of Free Extents", 
 round(nvl(max(free.bytes)/1024/1024,0),2) as "Max free extent", 
 round(sum(free.bytes)/1024/1024,2) as "Total Free Size(M)", 
 round(nvl(avg(free.bytes)/1024/1024,0),2) as "Avg Free extent Size(M)"
from 
 dba_data_files  total, 
 dba_free_space  free 
where 
 total.tablespace_name = free.tablespace_name(+) 
 and total.file_id=free.file_id(+)
group by 
total.tablespace_name
/

select sql_text from dba_hist_active_sess_history a,v$sqlarea l 
where a.sql_id=l.sql_id and a.event='db file scattered read'
and SAMPLE_TIME>sysdate-2;

db file scattered read

select /*+ sql_id from dba_hist_active_sess_history a 
where  a.event='db file scattered read'
and SAMPLE_TIME>sysdate-2;

select a.sql_id,sql_text from v$session_longops a,v$sqlarea b  where LAST_UPDATE_TIME >sysdate-0.1 and a.sql_id=b.sql_id
order by sql_text

SELECT a.tablespace_name,        
a.free_kb,     
b.size_kb-a.free_kb,   
Trunc((a.free_kb/b.size_kb) * 100) "FREE_%" 
FROM   
(SELECT tablespace_name,Trunc(Sum(bytes)/1024) free_kb FROM   dba_free_space GROUP BY tablespace_name) a,        
(SELECT tablespace_name,Trunc(Sum(bytes)/1024) size_kb FROM   dba_data_files GROUP BY tablespace_name) b 
WHERE  a.tablespace_name = b.tablespace_name order by Trunc((a.free_kb/b.size_kb) * 100)
/

select table_name,blocks,NUM_ROWS 
from dba_tables 
where owner='SAPSR3' 
and PARTITIONED='NO' 
and num_rows>10000000 
and blocks>200000 
order by blocks;

select LAST_ANALYZED,table_name,NUM_ROWS from dba_tables where owner='SAPSR3'
and NUM_ROWS>100000 and LAST_ANALYZED<sysdate-60 order by LAST_ANALYZED
admin43/ HNlcamapp43_


索引监控
select 'alter index '||owner||'.'||index_name||' monitoring usage;' from dba_indexes 
where table_name='MWT_UD_PD_SB_RH_YXWZ' and owner='MW_APP'

select io.name, t.name,
       decode(bitand(i.flags, 65536), 0, 'NO', 'YES'),
       decode(bitand(ou.flags, 1), 0, 'NO', 'YES'),
       ou.start_monitoring,
       ou.end_monitoring
from sys.obj$ io, sys.obj$ t, sys.ind$ i, sys.object_usage ou
where io.owner# = (select user_id from dba_users where username='&1')
  and i.obj# = ou.obj#
  and io.obj# = ou.obj#
  and t.obj# = i.bo#
  Yxyw-Hepc.002
set linesize 160
col owner format a30
col index_name format a40
col table_name format a30
SELECT u.name owner,  
       io.name index_name,  
       t.name table_name,  
       DECODE (BITAND (i.flags, 65536), 0, 'NO', 'YES') monitoring,  
       DECODE (BITAND (ou.flags, 1), 0, 'NO', 'YES') used,  
       ou.start_monitoring start_monitoring,  
       ou.end_monitoring end_monitoring  
FROM sys.user$ u,  
       sys.obj$ io,  
       sys.obj$ t,  
       sys.ind$ i,  
       sys.object_usage ou  
WHERE i.obj# = ou.obj# AND io.obj# = ou.obj# AND t.obj# = i.bo# AND u.user# = io.owner#  
       AND u.name=decode(upper('&input_owner'),'ALL',u.name,upper('&input_owner'))
       order by used
  
SELECT 'ALTER INDEX ' || owner || '.' || index_name || ' MONITORING USAGE;'  
 FROM dba_indexes  
 WHERE owner IN (SELECT username  
                  FROM dba_users  
                 WHERE account_status = 'OPEN')  
      AND owner NOT IN ('SYS', 'SYSTEM', 'PERFSTAT', 'MGMT_VIEW', 'MONITOR', 'SYSMAN', 'DBSNMP');  

col segment_name format a40
select /*+rule*/sum(bytes)/1024/1024,PARTITION_NAME,segment_type,owner 
from seg1 where PARTITION_NAME in( select SUBPARTITION_NAME from dba_tab_subpartitions where table_name='G_TG_CONS_DAY_PQ' and TABLE_OWNER='FDPSHARE')
and segment_type<>'INDEX SUBPARTITION'
group by PARTITION_NAME,segment_type,owner  
having sum(bytes)/1024/1024=32
order by sum(bytes)/1024/1024;


SQL> select count(*) from  FDPSHARE.G_TG_CONS_DAY_PQ subpartition(DATA20160530_PART43414);

  COUNT(*)
----------
         0

查询子分区数据：
DATA20160516_PART43414 
select count(*) from  FDPSHARE.G_TG_CONS_DAY_PQ subpartition(DATA20160516_PART43414);
select /*+rule*/ count(*) from dba_tab_partitions;

DATA20171229_PART43407

select select SUBPARTITION_NAME from dba_tab_subpartitions where table_name='G_TG_CONS_DAY_PQ' and TABLE_OWNER='FDPSHARE'


select 'ALTER INDEX ' || owner || '.' || segment_name || ' MONITORING USAGE;'  
from seg1 where segment_type='INDEX' and segment_name not in(select 
group by segment_name,segment_type,owner  
having sum(bytes)/1024/1024/1024>4 order by sum(bytes)/1024/1024/1024;

 select * from dba_ddl_locks where owner not in('SYS','SYSTEM');
 select * from dba_ddl_locks where owner not in('SYS');
分区表
SELECT LAST_ANALYZED,SUBPARTITION_NAME from dba_tab_subpartitions 
where table_name='ARC_E_MP_PARA_SNAP' and TABLE_OWNER='FDPSHARE'
ORDER BY LAST_ANALYZED

select count(distinct MP_PARA_SNAP_ID) from  "FDPSHARE"."ARC_E_MP_PARA_SNAP"  subpartition(ARC_E_MP_PARAS_43409_N1601);
DELETE FROM "FDPSHARE"."ARC_E_MP_PARA_SNAP"  WHERE "MP_PARA_SNAP_ID" = :b0


select TABLE_NAME,BLOCKS*8192/1024/1024/1024,PARTITION_NAME subname,SUBPARTITION_NAME subpname,
to_char(LAST_ANALYZED,'yyyy-mm-dd')  dt ,tablespace_name 
from dba_tab_subPARTITIONs 
where TABLE_NAME='A_RCVBL_ENTRY' and blocks>0 order by SUBPARTITION_NAME

dba角色权限
select * from dba_role_privs where granted_role='DBA' order by 1;
select * from gv$pwfile_users;

自动收集统计信息
EXEC DBMS_SCHEDULER.disable('SYS.GATHER_STATS_JOB');
EXEC DBMS_SCHEDULER.ENABLE('SYS.GATHER_STATS_JOB');

EXEC DBMS_SCHEDULER.disable('SYS.AUTO_SPACE_ADVISOR_JOB');
EXEC DBMS_SCHEDULER.ENABLE('SYS.AUTO_SPACE_ADVISOR_JOB');

10G数据库自动任务
col job_name format a40
select job_name,REPEAT_INTERVAL,last_start_date from dba_scheduler_jobs where job_name='T_SECT_REPORT_STAT_JOB'
col job_name format a30
select log_id,job_name,status,to_char(log_date,'yyyy-mm-dd hh24:mi:ss') log_date,RUN_DURATION from dba_scheduler_job_run_details
where job_name='MOVE_TASK_JOB' and log_date >sysdate-0.2 order by log_date
order by log_date;
select schedule_name,job_name from dba_scheduler_jobs where job_name='GATHER_STATS_JOB'
select * from dba_scheduler_wingroup_members where window_group_name='MAINTENANCE_WINDOW_GROUP';
select window_name,repeat_interval,duration from dba_scheduler_windows where window_name in('WEEKNIGHT_WINDOW','WEEKEND_WINDOW');

11G数据库自动任务
select client_name,status from dba_autotask_client;
select * from dba_autotask_windows_clients;
select * from dba_scheduler_running_jobs;
begin
dbms_scheduler.create_job(
job_name=>'test_job',
job_type='STROED_PROCEDURE',--三种 1：存储过程 2.pl/sql block 3.外部程序
job_action=>'xxxx_xxxx.xxxx',--存储过程名
start_date=>sysdate,
repeat_interval=>'FREQ=MONTHLY;INTERVAL=>1;BYMOUTHDAY=1;BYHOUR=1;BYMINUTE=0;BYSECOND=0',
conntents=>'test scheduler'
);
end;

运行:
dbms_scheduler.run_job('xxxx_job',true);
dbms_scheduler.enable('xxx_job');
dbms_scheduler.disable('xxxx_job');
dbms_scheduler.stop_job(job_name=>'xxx_job',force=>true);
dbms_scheduler.drop_job(job_name=>'xxx_job',force=>true);

dbms_scheduler包一些视图
--*代表all或dba或user
--1.查看job的视图
*_scheduler_jobs --查看job
*_scheduler_job_args  --查看job的所有输入参数
*_scheduler_job_classes --查看job的类信息
*_scheduler_job_dests --查看job状态
*_scheduler_job_log --查看job日志
*_scheduler_job_run_details --查看job执行的详细信息
all_scheduler_running_jobs

--2.查看chain的一些视图
*_scheduler_chains 
*_scheduler_chain_rules
*_scheduler_chain_steps
*_scheduler_running_chains --查看正在执行的chains

--3.查看program的视图
*_scheduler_programs --查看程序
*_scheduler_program_args --查看程序参数

--4.查看调度组信息 
*_scheduler_groups
*_scheduler_group_members

--5.查看window的视图（这类视图只有dba和all开头的）
*_scheduler_windows --查看window
*_scheduler_window_details --查看window详细信息
*_scheduler_window_groups --查看window组
*_scheduler_window_log --查看window日志
*_scheduler_wingroup_members ----查看window成员

--6.查看scheduler视图
*_scheduler_schedules --查看调度
*_scheduler_global_attribute --显示所有的调度属性
*_scheduler_credentials
*_scheduler_db_dests
*_scheduler_dests
*_scheduler_external_dests
*_scheduler_file_watchers
*_scheduler_notifications
*_scheduler_remote_databases
*_scheduler_remote_jobstate

三个概念
大多数人看到这个包里的函数和函数里众多的参数，就开始晕菜了，不要被这些表象迷惑了，其实这些东西都是围绕着三个基本概念，
schedule，program和job。oracle是为了复用的目的，提炼出了调度的这三个要素，弄懂这三个要素，立刻豁然开朗。

schedule
schedule表示调度计划表。调度从什么时间开始被调度，什么时候结束，以什么频度调度。使用DBMS_SCHEDULER.CREATE_SCHEDULE过程创建schedule。

 begin
    DBMS_SCHEDULER.CREATE_SCHEDULE (
      schedule_name     => ¨daily_schedule¨,
      start_date        => SYSDATE,
      repeat_interval   => ¨FREQ=DAILY ; INTERVAL=1¨,
      comments          => ¨every one day¨);
    END;
    /
其中repeat_interval参数，支持两种格式： 
- dbms_job里的interval格式，建议让这种晦涩语法见鬼去吧 
- 日历表达式（linux系统的crontab使用的格式）

日历表达式分为三部分: 第一部分是频率，也就是”FREQ”这个关键字，它是必须指定的; 第二部分是时间间隔，也就是”INTERVAL”这个关键字，取值范围是1-999. 它是可选的参数; 第三部分是附加的参数,可用于精确地指定日期和时间,它也是可选的参数,下面这些值都是合法的: 
BYMONTH,BYWEEKNO,BYYEARDAY,BYMONTHDAY,BYDAY 
BYHOUR,BYMINUTE,BYSECOND

看几个例子就会用了

每隔2小时运行一次
repeat_interval => 'FREQ=HOURLY; INTERVAL=2'
每天运行一次
repeat_interval => 'FREQ=DAILY'
每周的1,3,5运行
repeat_interval => 'FREQ=WEEKLY; BYDAY=MON,WED,FRI"
每年的3,6,9,12月的18号运行
repeat_interval => 'FREQ=YEARLY; BYMONTH=MAR,JUN,SEP,DEC; BYMONTHDAY=18'
另外使用dbms_scheduler.evaluate_calendar_string可以方便的计算出什么时候执行该调度。
program
program表示调度应该做什么事情，是对程序的抽象。使用DBMS_SCHEDULER.CREATE_PROGRAM创建program

 BEGIN
    DBMS_SCHEDULER.CREATE_PROGRAM (
       program_name           => ¨time_synchronization¨,
       program_action         => ¨/sbin/ntpdate 128.59.67.100¨,
       program_type           => ¨EXECUTABLE¨,
       enabled                => TRUE);
 END;
    /
调度现在可以支持调用外部程序了，这点很强大。 
目前程序支持三种类型: 
- PL/SQL块: PLSQL_BLOCK, 
- 存储过程: STORED_PROCEDURE 
- 外部程序: EXECUTABLE， 外部程序可以是一个shell脚本,也可以是操作系统级别的命令。

program_action: 根据program_type的不同，program_action有不同的含义。 
- program_type是存储过程，就需要指定存储过程的名字; 
- program_type是PL/SQL块，就需要输入完整的PL/SQL代码; 
- program_type是外部程序，就需要输入script的名称或者操作系统的指令名

job
job表示按照指定的schedule，执行指定program，完成用户指定的工作。使用DBMS_SCHEDULER.CREATE_JOB创建job。

SQL> BEGIN
  2  DBMS_SCHEDULER.CREATE_JOB (
  3     job_name           =>  ¨time_synchron¨,
  4     program_name       =>  ¨time_synchronization¨,
  5     schedule_name      =>  ¨daily_schedule¨,
  6     enabled            =>  true);
  7  END;
  8  /

调度的相关操作
作业相关操作
一般情况下是如果你设定了job的enable是true的话，oracle会按照你的计划，定时调用你的job，不需要手动执行。如果临时需要马上调度job也是可以的。
exec dbms_scheduler.run_job(¨time_synchron¨);
如果觉得没有必要继续执行这个job了，可以停止该job，让oracle以后不要再继续调度了。
exec dbms_scheduler.stop_job(¨time_synchron¨);
查看作业相关情况
Job 每执行一次，无论成功或失败，均会[DBA|ALL|USER]_SCHEDULER_JOB_LOG中生成一条对应的记录(前提是LOGGING_LEVEL属性值未设置为DBMS_SCHEDULER.LOGGING_OFF)，job的详细信息可以通过 
[DBA|ALL|USER]_SCHEDULER_JOB_RUN_DETAILS视图查看。


select JOB_NAME,OWNER,ENABLED,STATE,START_DATE,LAST_START_DATE,LAST_RUN_DURATION,NEXT_RUN_DATE,SCHEDULE_LIMIT,MAX_RUN_DURATION,run_count  from  dba_scheduler_jobs

exec dbms_scheduler.run_job(JOB_NAME=>'EXCHANGER30.VAL431011111111111111111121',use_current_session=>false);
dba_autotask_client
dba_autotask_client_history 
col CLIENT_NAME format a30
col WINDOW_NAME format a20
col WINDOW_START_TIME format a40
set wra off
select * from dba_autotask_client_history order by CLIENT_NAME,WINDOW_DURATION
select * from dba_autotask_window_history;

统计信息：
set wra off
select * from dba_tab_stats_history;


关闭开启
execute dbms_auto_task_admin.disable;
execute dbms_auto_task_admin.enable;
关闭指定的job
begin
dbms_auto_task_admin.disable(
client_name=>'auto space advisor',
operation=>NULL,
window_name=>NULL);
end;
/
开启指定的job
begin
dbms_auto_task_admin.enable(
client_name=>'auto space advisor',
operation=>null,
window_name=>null);
end;


隐含参数
col hidden_name format a50
col current_val format a30
col default_val format a30
select a.ksppinm hidden_name, b.ksppstvl current_val, b.KSPPSTDF default_val 
from X$KSPPI a, x$ksppsv b 
where a.indx = b.indx 
and a.ksppinm like '\_cursor%' escape '\'
order by 1;

col hidden_name format a50
col current_val format a30
col default_val format a30
select a.ksppinm hidden_name, b.ksppstvl current_val, b.KSPPSTDF default_val 
from X$KSPPI a, x$ksppsv b 
where a.indx = b.indx 
and a.ksppinm like '\_optimizer_distinct_placement%' escape '\'
order by 1;


分区表查询
select PARTITION_NAME,SUBPARTITION_NAME from dba_tab_subpartitions where table_name='' and owner='SGPMS';

查询未分析的表

select table_name,num_rows, LAST_ANALYZED,PARTITIONED  from dba_tables where owner='SGPMS' 
and  LAST_ANALYZED<sysdate-40 and num_rows>1000000 
and PARTITIONED='YES'
order by num_rows

pga使用情况
select sum(value)/1024/1024  mb from v$sesstat s,v$statname n where n.statistic#=s.statistic#;
select sum(value)/1024/1024 from v$statname n,v$sesstat  s where  n.statistic#=s.statistic# and name like 'session%memory%' order by 3 asc;

清除回收站
purge  dba_recyclebin;
收集数据词典信息：
删除系统用户统计信息
exec dbms_stats.delete_schema_stats('SYS');
exec dbms_stats.gather_fixed_objects_stats('X$KCCLE');

exec dbms_stats.gather_fixed_objects_stats;

提高回滚速度：
_cleanup_rollback_entries
rac 
11g oifcfg 命令
oifcfg iflist -p -n
查询事务回滚速度
select * from v$fast_start_transactions；

关闭haip

/u01/app/11.2.0/grid/bin/crsctl modify res ora.cluster_interconnect.haip -attr "ENABLED=0" -init
crsctl stop crs
crsctl start crs

查询归档备份情况：
set linesize 150
set wra off
alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
select THREAD#, SEQUENCE#,FIRST_TIME,DELETED, STATUS,name  from v$archived_log where FIRST_TIME>sysdate-1;
select sql_id,SESSION_ID,PROGRAM,MODULE,ACTION,SESSION_TYPE,MACHINE,event,SAMPLE_TIME from dba_hist_active_sess_history where PROGRAM like '%rman%' and SAMPLE_TIME>sysdate-1 order by SAMPLE_TIME 
 select PROGRAM,MODULE,ACTION,MACHINE,event from v$session where PROGRAM like '%rman%
 
set linesize 150
col NAME FORMAT a40
set wra off
alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
 select THREAD#, SEQUENCE#,FIRST_TIME,DELETED, STATUS,BACKUP_COUNT,name  from v$archived_log where FIRST_TIME>sysdate-4 and BACKUP_COUNT=0; 
 select SEQUENCE#,FIRST_TIME,NEXT_TIME,NAME from v$archived_log;

备份情况!!!!!!
set lines 400 
set pages 200 
set echo off 
set verify off 
set scan on 
col TIME_TAKEN_DISPLAY for a8 
col "INPUT(SUM)" for a9 
col "OUTPUT(SUM)" for a10 
col status for a9 
col "INPUT(s)" for a9 
col "OUTPUT(s)" for a9 
col OUTPUT_DEVICE_TYPE for a5 
col INPUT_TYPE for a7 
col start_time for a20 
col end_time for a20 
SELECT session_key, 
TO_CHAR (START_TIME, 'yyyy-mm-dd hh24:mi:ss') start_time, 
TO_CHAR (end_time, 'yyyy-mm-dd hh24:mi:ss') end_time, 
TIME_TAKEN_DISPLAY, 
INPUT_BYTES_DISPLAY "INPUT(SUM)", 
OUTPUT_BYTES_DISPLAY "OUTPUT(SUM)", 
OUTPUT_DEVICE_TYPE, 
STATUS, 
INPUT_TYPE, 
INPUT_BYTES_PER_SEC_DISPLAY "INPUT(s)", 
OUTPUT_BYTES_PER_SEC_DISPLAY "OUTPUT(s)" 
FROM v$rman_backup_job_details 
order by session_key; 
dataguard 常用命令：
set wra off
col name format a40
set linesize 150
select name,creator,sequence#,applied,completion_time from v$archived_log  where thread#=2  and applied='NO' order by sequence# ASC ;
select name,creator,sequence#,applied,completion_time from gv$archived_log  where  applied='NO' order by sequence#;
select min(sequence#),thread# from gv$archived_log  where  applied='NO' group by thread#;

select name,creator,sequence#,applied,completion_time from v$archived_log  where thread#=1  and applied='YES' order by sequence# ;
select name,creator,sequence#,applied,completion_time from v$archived_log  where thread#=2 and applied='YES' order by sequence#;
select name,creator,sequence#,applied,completion_time from v$archived_log  where  applied='YES' order by sequence# ;
select max(sequence#) from v$archived_log  where  applied='YES' order by sequence#;
select name,creator,sequence#,applied,completion_time from gv$archived_log  where  applied='NO' order by sequence#;

select process,client_process,sequence#,status from v$managed_standby;
select sql_id,machine from v$session where paddr=(select addr from v$process where spid='&1');
alter database recover managed standby database cancel;
drop and add standy redo log
alter database recover managed standby database using current logfile disconnect from session;
select first_time,first_change#,next_change#,next_change#,sequence# from v$log_history;
select thread#,max(sequence#) from v$log_history group by thread#;
alter database create datafile '/oracle/app/oracle/product/11.2.0/db_1/dbs/UNNAMED01089' as '+PMDBDATA1' size 30G
配置ADG 使用duplicate 一定要用静态注册。

营销ADG磁盘空间不足造成文件丢失处理办法：

ora-01111
ora-01110
ora-01157
文件系统： 
alter system set standby_file_management=manual sid='*';
alter database rename file '/oracle/app/oracle/product/11.2.0/db_1/dbs/UNNAMED01088' to '+data';
ASM 存储：
alter database create datafile '/oracle/app/oracle/product/11.2.0/db_1/dbs/UNNAMED00034' size 31G  as '+data';
创建完毕后。
调整参数。
alter system set standby_file_management=auto sid='*';
启动ADG。

alter system set "_system_trig_enabled"=true;



[root@]# echo 32 > /usr/openv/netbackup/db/config/NUMBER_DATA_BUFFERS 
echo 262144 > /usr/openv/netbackup/db/config/SIZE_DATA_BUFFERS  

停dataguard

select value from v$dataguard_stats where name='apply lag'

SQL>alter database recover managed standby database cancel;
SQL>shutdown immediate
启动standby database：
SQL>startup 
打开成只读模式：
SQL>alter database recover managed standby database using current logfile disconnect from session;
select open_mode,database_role from v$database;
v$archived_log的applied字段
v$archive_gap
v$managed_standby
v$log_history
v$dataguard_status
alter system set "_log_deletion_policy"=all;
alter database 
aler database activate standby database;
select (sysdate-to_date(to_char(scn_to_timestamp(applied_scn),'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss'))*24*60*60 from v$archive_dest
where target='STANDBY' AND DEST_ID=2;
select (sysdate-to_date(to_char(scn_to_timestamp(applied_scn),'yyyy-mm-dd hh24:mi:ss'),'yyyy-mm-dd hh24:mi:ss'))*24*60*60 from gv$archive_dest
where target='STANDBY' AND DEST_ID=2 and APPLIED_SCN>0; 
select scn_to_timestamp(current_scn) from v$database;
select current_scn from v$database;
select address,hash_value,executions,parse_calls from v$sqlarea where sql_id='7z11cfytagdy1';
exec sys.dbms_shared_pool.purge('00000024FC78BAE0','2997336001','c');
select 'exec sys.dbms_shared_pool.purge('''||address||','||hash_value||''','||'''c'');' from v$sqlarea where sql_id='&1';
5cntnf4qzdpc7
ADG 如果数据报告 
手工注册日志：
alter database register logfile '.../..../aaa.arc';
alter database register physical logfile '../...';
alter system flush redo to target_db_name;

duplicate database 
rman target sys/oracle@testzhu auxiliary sys/oracle@testbei log=/home/oracle/test.log<<EOF
run{
duplicate target database for standby nofilenamecheck from active database;
}
EOF

方法一：
应用redo
alter database recover managed standby database cancel;
recover standby database until cancel;
alter database recover managed standby database cancel;
alter database recover mamaged standby database finish force;
select database_role from v$database;
alter database commit to switchover to primary;
alter database open;
如果报错：
ora-16139 media recover required
alter database open read only
shutdown immediate
startup mount
alter database activate physical standby database;
alter database open;

方法二： 控制文件备份方式：
cp redo 到 standby 
pri
backup current controlfile for standby format '/tmp/a.ctl.b';
standby
restore standby controlfile from '/oracle/app/oracle/oradata/test/0614.ctl.bk';
alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
直接可以打开数据库。
切换数据库成主库。即可。

主备切换：
主库操作：

SQL> select switchover_status from v$database;
SWITCHOVER_STATUS
--------------------
TO STANDBY  -----如果显示为TO STANDBY  意味着能切换到standby 

SQL> alter database commit to switchover to physical standby;
Database altered.
SQL> startup mount
ORACLE instance started.
-------------------------等待备份切换到主库操作--------------------
Total System Global Area 1140109312 bytes
Fixed Size                  2260368 bytes
Variable Size             834667120 bytes
Database Buffers          268435456 bytes
Redo Buffers               34746368 bytes
Database mounted.
SQL>  
SQL> alter database recover managed standby database using current logfile disconnect from session;

Database altered.

SQL> alter database recover managed standby database cancel;

Database altered.

SQL> alter database open;

备库操作：
SQL> select  switchover_status from v$database;

SWITCHOVER_STATUS
--------------------
NOT ALLOWED    ----主库没有切换前的状态
SWITCHOVER_STATUS
--------------------
TO PRIMARY  ------主库切换后的状态
SQL> alter database commit to switchover to primary;

Database altered.

SQL> select  switchover_status from v$database;

SWITCHOVER_STATUS
--------------------
NOT ALLOWED

SQL> alter database open;

Database altered.


set linesize 250
set pagesize 200
col event format a30
col sid format 9999
col program format a30
col p2,p3 format 999999
select   sid,event,p1raw,p2, program,sql_id ,COMMAND,username
from  v$session  b  
where  paddr=(select addr from v$process where spid='&1')
/

select 'alter system kill session '''||sid||','||serial#||''';' from v$session where sql_id='&1';

select 'alter system kill session '''||sid||','||serial#||''';' from v$session where 
EVENT='row cache lock' and BLOCKING_INSTANCE=1

创建临时表空间：
create temporary tablespace TEMP tempfile '+RECOVERY/data/temp02.dbf' size 4G  autoextend on  maxsize 10G;
+RECOVERY/data/temp02.dbf                         4 TEMP
+RECOVERY/data/mws_temp02.dbf                     5 MWS_TEMP
+RECOVERY/data/mws_temp03.dbf                     2 MWS_TEMP
+RECOVERY/data/mws_temp1_01.dbf                   3 TEMP1
/lvdata1/lcamdb/datafile/
alter user EPMGIS    temporary tablespace temp1;
alter database default temporary tablespace temp1;
drop tablespace MWS_TEMP including contents and datafiles ;
drop tablespace COGNOS_DATA including contents and datafiles;
drop tablespace COGNOS_INDEX including contents and datafiles;
create tablespace  COGNOS_DATA datafile '+DATA' size 2G autoextend on maxsize 30G;
create tablespace  COGNOS_INDEX datafile '+DATA' size 2G autoextend on maxsize 30G;
交易平台数据库（10.223.31.41/42/44/45/47）新建表空间 COGNOS_DATA 和 COGNOS_INDEX （均

ALTER EXTRACT SPUMP01, EXTSEQNO 38, EXTRBA 0

delete REPLICAT RPVD
ADD REPLICAT RPVD, EXTTRAIL /ogghome/dirdat/VD

select name,ARCHIVED,APPLIED,STATUS from v$archived_log;

exec dbms_workload_repository.modify_snapshot_settings(interval=>30, retention=>40*24*60);


修改监听
listener.ora 加入如下参数
set INBOUND_CONNECT_TIMEOUT_***=0 
sqlnet.ora 加入如下参数
set SQLNET.INBOUND_CONNECT_TIMEOUT = 0 
重启监听生效。

col get_system_change_number format 9999999999999999999
select dbms_flashback.get_system_change_number from dual;

select t.owner,t.table_name,t.LAST_ANALYZED,t.PARTITIONED,t.num_rows,s.blocks*8192/1024/1024||'M' "table_M"  from dba_tables t,dba_segments s where t.owner='SAPSR3' 
 and s.blocks>10000 and t.table_name=s.segment_name and t.owner=s.owner and t.PARTITIONED='NO' order by s.blocks;
 
 RAC环境UNDO使用情况监控
select a.inst_id,trunc(activeblks/totalblks*100,2) "Active%",trunc(unexpiredblks/totalblks*100,2) "Unexpire%",totalblks*8192/1024/1024
from 
(select inst_id, sum(blocks) as totalblks from dba_data_files, gv$parameter
where tablespace_name = value and  name='undo_tablespace' group by inst_id) a ,
(select distinct inst_id,activeblks,unexpiredblks
from gv$undostat where  end_time >(sysdate-2/(60*24))) b
where a.inst_id=b.inst_id

select sid,serial#,sql_id,START_TIME from v$session s,v$transaction t where s.taddr=t.addr and  to_date(START_TIME,'mm/dd/yy hh24:mi:ss')<sysdate-1
包体被锁查询：
library lock
 select * from dba_ddl_locks where name='DWZY';
  select * from dba_ddl_locks where owner='DWZY'
 rac hang 分析
 oradebug setmypid
 oradebug setinst all
 oradebug hanganalyze 3
 
 select sql_id from v$sql 
 
清除分布式事务：
rollback force '131.13.3205';
commit force '442.37.206723';

commit;
EXECUTE dbms_transaction.purge_lost_db_entry('442.37.206723');
select * from   dba_2pc_neighbors
select * from dba_2pc_pending;

分布式事务异常处理流程：
1. 查询本地异常分布式事务情况：
select local_tran_id,DATABASE from   dba_2pc_neighbors
select local_tran_id,state  from dba_2pc_pending;
样例：
SQL> select local_tran_id,state,DATABASE from  dba_2pc_neighbors ;
LOCAL_TRAN_ID          IN_ DATABASE
---------------------- --- ---------------------------------------------------------------------------------------------------------------------------
442.37.206723          in
442.37.206723          out SGDC_MARKET_ODS

查询远程服务器分布式事务情况:
select local_tran_id,state  from dba_2pc_pending;
select local_tran_id,state,DATABASE from   dba_2pc_neighbors
2. 强制提交异常份不式事务：
commit force 'local_tran_id';
样例：
commit force '442.37.206723';
3. 清除异常分布式事务信息：
EXECUTE dbms_transaction.purge_lost_db_entry('local_tran_id');
样例：
EXECUTE dbms_transaction.purge_lost_db_entry('local_tran_id');
4. 备注:
如果强制提高异常需要手工清除。操作步骤比较复杂。而且有风险。
暂时不提高详细操作。需要清理数据词典。风险比较高。
手工强制删除：
步骤一:手工删除数据词典记录
1.delete from sys.pending_trans$ 
where local_tran_id = '156.23.65856'; 
2.delete from sys.pending_sessions$ 
where local_tran_id = '156.23.65856'; 
3.delete from sys.pending_sub_sessions$ 
where local_tran_id ='156.23.65856'; 
commit;  
步骤二. 按照以下方法手工插入记录 
步骤三：提交pending 事务
Commit force '156.23.65856' 
步骤四：清除事务
 exec dbms_transaction.purge_lost_db_entry('156.23.65856')'
 
 
备份恢复相关视图
v$backup_files
v$backup_set
v$backup_piece (重点）
v$backup_redolog 
v$backup_spfile
v$backup_device
v$backup_configauration
v$archive_log
v$backup_corruption
v$copy_corruption
v$database_block_corruption
v$backup_datafile
查看备份恢复情况：
select  INPUT_TYPE,OUTPUT_BYTES/1024/1024/1024 output_GB,ELAPSED_SECONDS/60 min,status,
INPUT_BYTES_PER_SEC_DISPLAY input,OUTPUT_BYTES_PER_SEC_DISPLAY output,TO_CHAR(START_TIME,'mm/dd/yy hh24:mi') start_time,
TO_CHAR(END_TIME,'mm/dd/yy hh24:mi') end_time from V$RMAN_BACKUP_JOB_DETAILS where INPUT_TYPE='DB INCR' and status<>'COMPLETED' order by start_time

select  INPUT_TYPE,OUTPUT_BYTES/1024/1024/1024 output_GB,ELAPSED_SECONDS/60 min,status,
INPUT_BYTES_PER_SEC_DISPLAY input,OUTPUT_BYTES_PER_SEC_DISPLAY output,TO_CHAR(START_TIME,'mm/dd/yy hh24:mi') start_time,
TO_CHAR(END_TIME,'mm/dd/yy hh24:mi') end_time from V$RMAN_BACKUP_JOB_DETAILS where INPUT_TYPE='ARCHIVELOG' order by start_time

select  sum(OUTPUT_BYTES)/1024/1024/1024 from V$RMAN_BACKUP_JOB_DETAILS  order by start_time


查看表更新情况（记录变化）
col PARTITION_NAME format a1
col SUBPARTITION_NAME format a1
MLOG$_T_SB_ZWYC_WLG 
select * from dba_tab_modifications where TABLE_NAME='MLOG$_T_SB_ZWYC_WLG';
where table_owner<>'SYS' and (inserts>100000 or updates>100000 or deletes>10000)  and TIMESTAMP>sysdate-10  
 and PARTITION_NAME is null and SUBPARTITION_NAME is null order by updates
exec dbms_stats.flush_database_monitoring_info(); 刷新纪录
set wra off
set linesize 180
col TABLE_OWNER format a15 
col TABLE_NAME format a30
col PARTITION_NAME format a20
col SUBPARTITION_NAME format a20
alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';

select TABLE_OWNER,TABLE_NAME,INSERTS,UPDATES,deletes,TIMESTAMP,PARTITION_NAME
 from dba_tab_modifications where   TIMESTAMP>sysdate-3 and (INSERTS+updates+deletes)>10000000
 order by (INSERTS+updates+deletes)
 
 select * from dba_tab_modifications where TABLE_OWNER='FMIS2000'  and table_name=upper('zwdxjehzb2018') order by INSERTS ;
select * from dba_tab_modifications  where table_name=upper('t_sb_bpbj_bpsbdyglb');


t_sb_bpbj_bpsbdyglb
select a.TABLE_OWNER,a.TABLE_NAME,a.INSERTS-b.INSERTS,a.updates,a.updates-b.updates,a.deletes-b.deletes,a.TIMESTAMP,b.TIMESTAMP
from dba_tab_modifications a,modi_bak b where a.TABLE_OWNER=b.TABLE_OWNER and a.TABLE_NAME=b.TABLE_NAME
and a.updates>100000 and 
and 

select * from dba_tab_modifications a where a.updates>1000 and table_name='E_MP_DAY_READ' and PARTITION_NAME>'DATA20181202' order by  a.updates

select a.TABLE_OWNER,a.TABLE_NAME,a.INSERTS,a.INSERTS-b.INSERTS,a.updates,a.updates-b.updates,a.deletes-b.deletes,a.TIMESTAMP,b.TIMESTAMP
from dba_tab_modifications a,modi_bak b where a.TABLE_OWNER=b.TABLE_OWNER and a.TABLE_NAME=b.TABLE_NAME
and (a.INSERTS+a.updates+a.deletes)-(b.INSERTS+b.updates+b.deletes)>100000
order by (a.INSERTS+a.updates+a.deletes)

select * from modi_bak  where TABLE_NAME like 'MLOG$_T_DW_SBBG_BGSB%';
T_MXPMS_ODS_INCDATA_BATCH47

select * from dba_tab_modifications where TABLE_NAME like 'MLOG$_T_DW_SBBG_BGSB%';
select * from dba_tab_modifications where TABLE_NAME ='T_QUANTITY_DAY_DAXY';
select * from modi_bak where TABLE_NAME ='T_MXPMS_ODS_INCDATA_BATCH47';

T_MXPMS_ODS_INCDATA_BATCH47
 查询情况。
create table modi_bak 
as 
select * from dba_tab_modifications where TABLE_OWNER='SCYW' order by INSERTS ;
select TABLE_OWNER,TABLE_NAME,INSERTS,UPDATES,deletes,to_char(TIMESTAMP,'yyyy-mm-dd hh24:mi:ss'),PARTITION_NAME
 from dba_tab_modifications where table_name='RCA_CONS_CURINFO' and table_owner='SGRCA_OWNER' 
 and TIMESTAMP>sysdate-4
 order by (INSERTS+updates+deletes)
 
 create table modi_bak from 
 
select message from v$dataguard_status;
and TIMESTAMP>to_date('2017-05-10','yyyy-mm-dd') and TIMESTAMP<to_date('2017-05-13','yyyy-mm-dd')
group by to_char(TIMESTAMP,'yyyy-mm-dd')   ;
hp-unix 
/opt/perf/bin/extract  -g -b 07/01/17 -e 08/24/17 -xp

容量分析：
select a.*,b.USED,a.sz*b.USED/100,a.sz*b.USED/5/100 from (select sum(bytes)/1024/1024/1024 sz,a.name, 
decode(to_char(CREATION_TIME,'yyyy'),null,'total') toal from
 (select t.name, CREATION_TIME,BYTES from v$datafile d ,v$tablespace t
where d.TS#=t.TS#)a 
group by rollup(a.name, to_char(CREATION_TIME,'yyyy'))
order by a.name,to_char(CREATION_TIME,'yyyy'))a 
left join 
(SELECT a.tablespace_name,       Trunc(100-(a.free_kb
/b.size_kb) * 100) USED FROM   (SELECT tablespace_name,              
Trunc(Sum(bytes)/1024) free_kb FROM   dba_free_space  GROUP BY tablespace_name) a,      
  (SELECT tablespace_name,                Trunc(Sum(bytes)/1024) size_kb        
   FROM   dba_data_files         GROUP BY tablespace_name) b WHERE 
    a.tablespace_name = b.tablespace_name and a.tablespace_name not like 'UNDO%' 
    order by Trunc((a.free_kb/b.size_kb) * 100) )b
 ON  a.name=b.tablespace_name WHERE  A.toal='total'
 
 aix 调整磁盘双路径读写；
chdev -l hdisk48 -a reserve_policy=no_reserve
chdev -l hdisk49 -a reserve_policy=no_reserve

清理磁盘信息：
dd if=/dev/zero of=/dev/dm-10 bs=8192 count=1000

游标打开情况：

 SELECT 'session_cached_cursors' PARAMETER,  
       LPAD(VALUE, 5) VALUE,  
       DECODE(VALUE, 0, ' n/a', TO_CHAR(100 * USED / VALUE, '9900000') || '%') USAGE  
  FROM (SELECT MAX(S.VALUE) USED  
          FROM V$STATNAME N, V$SESSTAT S  
         WHERE N.NAME = 'session cursor cache count'  
           AND S.STATISTIC# = N.STATISTIC# ),  
       (SELECT VALUE FROM V$PARAMETER WHERE NAME = 'session_cached_cursors')  
UNION ALL  
SELECT 'open_cursors',  
       LPAD(VALUE, 5),  
       TO_CHAR(100 * USED / VALUE, '9990') || '%'  
  FROM (SELECT MAX(SUM(S.VALUE)) USED  
          FROM V$STATNAME N, V$SESSTAT S  
         WHERE N.NAME IN  
               ('session cursor cache count')  
           AND S.STATISTIC# = N.STATISTIC#   
         GROUP BY S.SID),  
       (SELECT VALUE FROM V$PARAMETER WHERE NAME = 'open_cursors');        
 SELECT   S.VALUE,sid
 FROM V$STATNAME N, V$SESSTAT S  
 WHERE N.NAME = 'session cursor cache count'  
 AND S.STATISTIC# = N.STATISTIC# and  S.VALUE >10 order by S.VALUE
 
 SELECT S.VALUE,sid
          FROM V$STATNAME N, V$SESSTAT S  
         WHERE N.NAME = 'session cursor cache count'  
           AND S.STATISTIC# = N.STATISTIC# and  S.VALUE >10 order by S.VALUE   
           
 username session查询
 select count(*),machine,inst_id from gv$session group by machine,inst_id;
  select count(*),machine from gv$session group by machine,inst_id;
 
修改awr报告保留情况：
exec dbms_workload_repository.modify_snapshot_settings(interval=>60, retention=>31*24*60);  
exec dbms_workload_repository.modify_snapshot_settings(interval=>30, retention=>60*24*60);
exec DBMS_WORKLOAD_REPOSITORY.CREATE_SNAPSHOT();

sysdba
select * from gv$pwfile_users;


强行连接数据库：
sqlplus -prelim "/as sysdba"


rman 常用错误分析
RMAN-06091: no channel allocated for maintenance (of an appropriate type)
allocate channel for maintenance device type 'sbt_tape';
allocate channel for maintenance device type disk;


在线补丁：
cd <patch_path>
opatch rollback -id 14275161 -connectString hnvpd1:oracle:\!QAZ2wsx:cwgkdb1,hnvpd2:oracle:\!QAZ2wsx:cwgkdb2
cd <patch_path>
opatch apply online -connectString hnvpd1:oracle:\!QAZ2wsx:cwgkdb1,hnvpd2:oracle:\!QAZ2wsx:cwgkdb2

查询是否可以在线打补丁
cd <patch_path>
opatch query -all online

sqlplus 生成excel 表格或者html格式文本
sqlplus -s / as sysdba << !
set linesize 200 
set term off verify off feedback off pagesize 999 
set markup html on entmap ON spool on preformat off
spool test.xls
@tabspace.sql;
spool off 
exit;
EOF
select 'availability' as checking_class,'database-status-'||name as checking_name,decode(OPEN_MODE,'READ WRITE','OK') AS STATUS from gv$database
union all 
select 'availability' as checking_class,'instance-status-'||INSTANCE_NAME as checking_name,decode(STATUS,'OPEN','OK') AS STATUS from gv$instance;
标上行号：
sed = a.txt|sed 'N;s/\n/\t/'>b.txt
取行号：
cat b.txt|grep "\"pmdba\""
取具体行：
sed -n '27,28p' b.txt >c.txt

alter system set "_gc_defer_time"=3 scope=both sid='*';

dataguard
desc v$archived_log
set linesize 150
select SEQUENCE#,ARCHIVED,APPLIED,NEXT_TIME,THREAD#,NAME,FIRST_TIME from v$archived_log;

资源限制及安全管理：
select * from v$resource_limit;
select * from dba_profiles;
v$open_cursor
#####################
select sql_text,LAST_SQL_ACTIVE_TIME from v$open_cursor where sid='&1' and upper(sql_text) like '%T_ZH_ZTJX_PDSBBJPJJG%' order by LAST_SQL_ACTIVE_TIME;

统计信息收集：
11G:
SELECT w.window_name, w.repeat_interval, w.duration, w.enabled,w.SCHEDULE_NAME
FROM dba_autotask_window_clients c, dba_scheduler_windows w
WHERE c.window_name = w.window_name
AND c.optimizer_stats = 'ENABLED';
--禁用自动收集
exec DBMS_AUTO_TASK_ADMIN.DISABLE(client_name => 'auto optimizer stats collection',operation => NULL,window_name => NULL);
exec DBMS_AUTO_TASK_ADMIN.DISABLE(client_name => 'auto space advisor',operation => NULL,window_name => NULL);
exec DBMS_AUTO_TASK_ADMIN.DISABLE(client_name => 'sql tuning advisor',operation => NULL,window_name => NULL);
--启用自动收集
exec DBMS_AUTO_TASK_ADMIN.ENABLE(client_name => 'auto optimizer stats collection',operation => NULL,window_name => NULL);
--查看job
select client_name,status from dba_autotask_client;
CLIENT_NAME                                                      STATUS
-------------------------------------------------------------   --------
auto optimizer stats collection                                 ENABLED
auto space advisor                                              ENABLED
sql tuning advisor                                              ENABLED
12170
select dbms_stats.get_prefs('method_opt') from dual;
select dbms_stats.get_prefs('concurrent') from dual; 
select dbms_stats.get_prefs('GRANULARITY') from dual;
select dbms_stats.get_prefs('INCREMENTAL') from dual;
集群常用命令：
srvctl status srvpool -g racpool -a
srvctl status database -d mvpdb
srvctl status srvpool -a
srvctl status server -n hnzycdb1 -a
srvctl config serverpool -g sername
srvctl config database -d bpmdb 
srvctl status dbname
srvctl config dbname

crsctl status serverpool  -p

local_listener

alter system set local_listener='(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=10.223.6.87)(PORT=11521))))' sid='bpmdb_1';
srvctl config scan_listener
srvctl modify scan_listener -p 11521
P16-root.db1

表分析SQL
select 'exec dbms_stats.GATHER_TABLE_STATS(''DUNS'','''||table_name ||''',estimate_percent=>5,cascade=>true,degree=>4 );' 
from dba_tables where owner='DUNS';
select 'exec dbms_stats.GATHER_INDEX_STATS(''SAPSR3'',''"'||index_name ||'"'',estimate_percent=>100 );' 
from dba_indexes where owner='SAPSR3' and table_name='BKPF';

表空间增长速度：
v$datafile
v$tablespaces
select sum(BYTES)/1024/1024/1024,t.name from v$datafile d,v$tablespace t where d.ts#=t.ts# and CREATION_TIME>sysdate-360 group by t.name;
select sum(BYTES)/1024/1024/1024 from v$datafile d,v$tablespace t where d.ts#=t.ts# and CREATION_TIME>sysdate-90;

bug:13527323 ora-06502 
临时解决办法：
update wrh$_sqltext set sql_text=substr(sql_text,1,1000);

 execute dbms_sqltune.accept_sql_profile(task_name => 'TASK_31456',task_owner => 'SYS', replace => TRUE, profile_type =>DBMS_SQLTUNE.PX_PROFILE);
 select count(*) from SGBIZ.ba_userca as of timestamp to_timestamp('2015-08-21 10:30:00','yyyy-mm-dd hh24:mi:ss');
 select to_char(LAST_ACTIVE_TIME,'yyyy-mm-dd hh24:mi:ss'),sql_text from v$sqlarea where sql_text like '%ba_userca%' or sql_text like '%BA_USERCA%';

闪回
select count(*) from fmis9999.xtbill2019 as of timestamp to_timestamp('2019-04-28 16:26:00','yyyy-mm-dd hh24:mi:ss');

supplemental log data:

select * from dba_log_group_columns where TABLE_NAME='C_METER';
select * from dba_constraints where table_name='C_METER' and owner='SGPMS';
select * from dba_constraints where table_name='C_METER' and owner='SGPMS';
set linesize 150
set wra off
col OWNER format a20
col LOG_GROUP_NAME format a30
col TABLE_NAME format a20
col COLUMN_NAME format a30
select * from dba_log_group_columns where TABLE_NAME='C_METER'

select * from 
(select OWNER,TABLE_NAME,COLUMN_NAME,POSITION,count(*) cnt from dba_log_group_columns  group by OWNER,TABLE_NAME,COLUMN_NAME,POSITION )
a where a.cnt>1;

分布式
 select * from v$px_session;、
 select * from dba_pending_transactions;
 select s.inst_id,sid,serial#,sql_id from gv$session s,gv$transaction t where s.taddr=t.addr;
col event format a30
col program format a30
select p.inst_id,p.siD,p.SERIAL#,p.QCSID,p.QCSERIAL#,p.DEGREE,s.event,s.program  from
 gv$px_session p,gv$session s  where  QCSID in('890','909') and s.sid=p.sid 
 
 select p.inst_id,p.siD,p.SERIAL#,p.QCSID,p.QCSERIAL#,p.DEGREE,s.event,s.program  from
 gv$px_session p,gv$session s  where   s.sid=p.sid 
 
临时段使用情况：
select USERNAME,SQL_ID,sum(BLOCKS)*8192/1024/1024/1024,count(*) from gv$sort_usage t
 group by  USERNAME,SQL_ID having sum(BLOCKS)>10000 order by sum(BLOCKS)
 
 select PREV_SQL_ID from v$session where sql_id='bunvx480ynf57';
 
 select s.sql_id ,t.BLOCKS from gv$session s,gv$sort_usage t where s.saddr=t.session_addr and t.BLOCKS>10000
 select sum(BLOCKS) from gv$sort_usage where t.BLOCKS>10000;
  dba_hist_active_sess_history 
   select sql_id,TEMP_SPACE_ALLOCATED/1024/1024/1024,SAMPLE_TIME,IN_JAVA_EXECUTION from dba_hist_active_sess_history where   SAMPLE_TIME>sysdate-0.5 and 
   TEMP_SPACE_ALLOCATED/1024/1024/1024>100


select s.sql_id ,t.BLOCKS from v$session s,v$sort_usage t where s.saddr=t.session_addr;
 
rac 常用命令：
ocrcheck
ocrconfig backup
./ocrconfig  -manualbackup
./ocrconfig  -local -manualbackup
crsctl query css votedisk
crsctl check crs
crsctl stat res -p 
crsctl stat res -t
srvctl config scan
srvctl config listener 

更换CRS及votedisk
10G 磁盘：
crs磁盘：
./ocrcheck
./ocrconfig -add +newcrs
./ocrcheck config
./ocrconfig -delete +oldcrs
votedisk:
./crsctl query css votedisk
./crsctl replace votedisk +newcrs
./crsctl query css votedisk
asm：实例：
create pfile='/tmp/a.ora' from spfile;
create spfile='+newcrs' from pfile='/tmp/.a.ora';

4:30


分析系统物理表:
exec dbms_stats.gather_fixed_objects_stats();

@?/rdbms/admin/ashrpt.sql
@?/rdbms/admin/awrsqrpt.sql b4140rurcbbnv
awrgrpt.sql


select locality,index_name,table_name from dba_part_indexes;

RAC环境UNDO使用情况监控
select a.inst_id,trunc(activeblks/totalblks*100,2) "Active%",trunc(unexpiredblks/totalblks*100,2) "Unexpire%"
from 
(select inst_id, sum(blocks) as totalblks from dba_data_files, gv$parameter
where tablespace_name = value and  name='undo_tablespace' group by inst_id) a ,
(select distinct inst_id,activeblks,unexpiredblks
from gv$undostat where  end_time >(sysdate-2/(60*24))) b
where a.inst_id=b.inst_id

top 10 sql 语句 
dba_hist_sqlstat dba_hist_snapshot dba_hist_sqltext 

select * from 
   (select 
    t.SQL_id,
    sum(s.CPU_TIME_DELTA)/(1000*1000*60), 
    sum(s.DISK_READS_DELTA)/(1000*1000*60), 
    count(*) 
    from DBA_HIST_SQLSTAT s, DBA_HIST_SNAPSHOT p, DBA_HIST_SQLTEXT t 
    where 1=1 
    and s.SNAP_ID = p.SNAP_ID 
    and s.SQL_ID = t.SQL_ID 
    and EXTRACT(HOUR FROM p.END_INTERVAL_TIME) between 8 and 16 
    and t.COMMAND_TYPE != 47
    and p.END_INTERVAL_TIME between SYSDATE-1 and SYSDATE 
   group by t.sql_id
   order by sum(s.CPU_TIME_DELTA) desc 
   ) 
where rownum < 20
dlzlsm#$100

SYS_SQLPROF_015291c115291c17   DEFAULT                        3.1537E+18 SELECT*FROM "ZEP_FICO_001" WHERE "MANDT"=:A0 AND "ZZBYXSJ" BETWEEN :A1 AND :A2   14-DEC-14       14-DEC-14
SYS_SQLPROF_015291c115291c1e   DEFAULT                        4.7117E+18 SELECT*FROM "ZEP_FICO_001" WHERE "MANDT"=:A0 AND "ZZBYXSJ" BETWEEN :A1 AND :A2   14-DEC-14       14-DEC-14
SYS_SQLPROF_015291c215291c24   DEFAULT                        1.8099E+19 SELECT MAX(T_01."AWREF") "AWREF",T_04."DATV1" "DATV1",T_04."PERNR" "PERNR",T_0   14-DEC-14       14-DEC-14
SYS_SQLPROF_015291c215291c2b   DEFAULT                        6.4435E+17 SELECT /*+ FIRST_ROWS (1) */ "LIFNR" FROM "LFA1" WHERE "MANDT"=:A0 AND "LIFNR"   14-DEC-14       14-DEC-14
SYS_SQLPROF_015291c215291c2c   DEFAULT                        1.1218E+19 SELECT /*+ FIRST_ROWS (1) */ "LIFNR" FROM "LFA1" WHERE "MANDT"=:A0 AND "LIFNR"   14-DEC-14       14-DEC-14
SYS_SQLPROF_015293031529303d  

exec DBMS_SQLTUNE.DROP_SQL_PROFILE('SYS_SQLPROF_0169bc95c83b0001');
exec DBMS_SQLTUNE.DROP_SQL_PROFILE('coe_gsb77c6kuzwz5_1788284809');

查看执行计划！！！！！
绑定基线
Enter value for sql_id: 7vsd4rxam2yd7
old   1: select a.* from table(dbms_xplan.display_cursor('&sql_id',null,'ADVANCED'))a
new   1: select a.* from table(dbms_xplan.display_cursor('9jshhp8nvp045
',null,'ADVANCED'))a


gsb77c6kuzwz5
 select a.* from table(dbms_xplan.display_cursor('&sql_id',null,'ADVANCED'))a;
 
variable cnt number;
exec :cnt:=DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE(sql_id=>'7wk6f1snaby67', plan_hash_value => 1456006572,enabled=> 'YES');
exec DBMS_SQLTUNE.DROP_SQL_PROFILE('coe_6z4vh6j1d0v2c_323663900');
select TASK_NAME,CREATED,STATUS from user_advisor_tasks where TASK_NAME='TASK_39348'

execute dbms_stats.gather_table_stats(ownname => 'GWDLDXPT', tabname =>'TD_SMSS_RPT_SYSTEM_DONE', estimate_percent =>10, method_opt => 'FOR ALL COLUMNS SIZE AUTO', cascade => TRUE,degree=>16);
explain plan for
delete  from sgrca_owner.es_consprc_tact_snap a  where (a.org_no=:b1 and exists
(select 1  from sgrca_owner.es_cons_snap xa where ((xa.org_no=:b1 and
xa.batch_no=:b3) and a.calc_id=xa.calc_id)))

select * from table(dbms_xplan.display(null,null,'ADVANCED'))a

undo使用情况查询
RAC环境UNDO使用情况监控
select a.inst_id,trunc(activeblks/totalblks*100,2) "Active%",trunc(unexpiredblks/totalblks*100,2) "Unexpire%"
from 
(select inst_id, sum(blocks) as totalblks from dba_data_files, gv$parameter
where tablespace_name = value and  name='undo_tablespace' group by inst_id) a ,
(select distinct inst_id,activeblks,unexpiredblks
from gv$undostat where  end_time >(sysdate-2/(60*24))) b
where a.inst_id=b.inst_id

UNDO使用追踪
select s.usn,n.name,s.extents,s.XACTS,s.CURBLK,s.status from v$rollstat s, v$rollname n 
where s.usn=n.usn  and  xacts>0;
select SES_ADDR, xidusn,xidslot,xidsqn,USED_UBLK,UBAFIL from v$transaction order by USED_UBLK;
select t.tablespace_name,t.status,sum(t.bytes)/1024/1024/1024 from dba_undo_extents t 
group by t.tablespace_name, t.status order by 1,2;

undo 事物查询
SELECT /*+rule*/ S.SID,  
         S.USERNAME,  
         U.NAME,  
         Q.SQL_TEXT,  
         Q.HASH_VALUE,  
         T.UBABLK  
FROM V$TRANSACTION T,  
         V$ROLLSTAT R,  
         V$ROLLNAME U,  
         V$SESSION S,  
         V$SQLAREA Q  
WHERE    S.TADDR = T.ADDR  
         AND T.XIDUSN = R.USN  
         AND R.USN = U.USN  
         AND Q.HASH_VALUE =  
         DECODE(S.SQL_HASH_VALUE,  
         NULL, S.PREV_HASH_VALUE,  
         S.SQL_HASH_VALUE)  
ORDER BY S.USERNAME;

---SNAP_ID查询
SELECT SNAP_ID,snap_id+1,to_char(BEGIN_INTERVAL_TIME,'yyyymmddhh24') FROM DBA_HIST_SNAPSHOT
order by to_char(BEGIN_INTERVAL_TIME,'yyyymmddhh24')
----CPU消耗厉害的语句
select e.sql_id,
       decode(nvl(b.dbid, 0),
              0,
              e.buffer_gets_delta - nvl(b.buffer_gets_delta, 0),
              e.buffer_gets_total - nvl(b.buffer_gets_total, 0)) as b_gets, -- Buffer Gets
       --                                 cmpNumbers(b.dbid,b.buffer_gets_delta,e.buffer_gets_delta,b.buffer_gets_total,e.buffer_gets_total) as b_gets ,
       decode(nvl(b.dbid, 0),
              0,
              e.executions_delta - nvl(b.executions_delta, 0),
              e.executions_total - nvl(b.executions_total, 0)) as execs, -- Executions
       trunc(decode(nvl(b.dbid, 0),
                    0,
                    e.cpu_time_delta - nvl(b.cpu_time_delta, 0),
                    e.cpu_time_total - nvl(b.cpu_time_total, 0)) / 1000000,
             1) as cpu_time, -- CPU Time (s)
       trunc(decode(nvl(b.dbid, 0),
                    0,
                    e.elapsed_time_delta - nvl(b.elapsed_time_delta, 0),
                    e.elapsed_time_total - nvl(b.elapsed_time_total, 0)) /
             1000000,
             1) as elap_time, -- Elapsed Time (s)
       e.module,
       decode(nvl(b.dbid, 0),
              0,
              e.disk_reads_delta - nvl(b.disk_reads_delta, 0),
              e.disk_reads_total - nvl(b.disk_reads_total, 0)) as p_reads
  from sys.wrh$_sqlstat e, sys.wrh$_sqlstat b
 where b.snap_id(+) = &b_snap
   and e.snap_id = &e_snap
   and b.dbid(+) = e.dbid
   and b.instance_number(+) = e.instance_number
   and b.sql_id(+) = e.sql_id
   and b.plan_hash_value(+) = e.plan_hash_value
   and e.executions_total > nvl(b.executions_total, 0)
 order by cpu_time desc;
set linesize 999
set wra on
set long 99999
set linesize 200
select sql_fulltext from v$sqlarea where sql_id='&1';


----CPU排序--------------

select e.sql_id,
       decode(nvl(b.dbid, 0),
              0,
              e.buffer_gets_delta - nvl(b.buffer_gets_delta, 0),
              e.buffer_gets_total - nvl(b.buffer_gets_total, 0)) as b_gets, -- Buffer Gets
       --                                 cmpNumbers(b.dbid,b.buffer_gets_delta,e.buffer_gets_delta,b.buffer_gets_total,e.buffer_gets_total) as b_gets ,
       decode(nvl(b.dbid, 0),
              0,
              e.executions_delta - nvl(b.executions_delta, 0),
              e.executions_total - nvl(b.executions_total, 0)) as execs, -- Executions
       trunc(decode(nvl(b.dbid, 0),
                    0,
                    e.cpu_time_delta - nvl(b.cpu_time_delta, 0),
                    e.cpu_time_total - nvl(b.cpu_time_total, 0)) / 1000000,
             1) as cpu_time, -- CPU Time (s)
       trunc(decode(nvl(b.dbid, 0),
                    0,
                    e.elapsed_time_delta - nvl(b.elapsed_time_delta, 0),
                    e.elapsed_time_total - nvl(b.elapsed_time_total, 0)) /
             1000000,
             1) as elap_time, -- Elapsed Time (s)
       e.module,
       decode(nvl(b.dbid, 0),
              0,
              e.disk_reads_delta - nvl(b.disk_reads_delta, 0),
              e.disk_reads_total - nvl(b.disk_reads_total, 0)) as p_reads,
              to_char(substr(c.sql_text,1,2000))
  from sys.wrh$_sqlstat e, 
  
 where b.snap_id(+) = 51572
   and e.snap_id = 51573
   and b.dbid(+) = e.dbid
   and e.INSTANCE_NUMBER=2
   and b.instance_number(+) = e.instance_number
   and b.sql_id(+) = e.sql_id
   and c.sql_id=e.sql_id
   and b.plan_hash_value(+) = e.plan_hash_value
   and e.executions_total > nvl(b.executions_total, 0)
   and   trunc(decode(nvl(b.dbid, 0),
                    0,
                    e.cpu_time_delta - nvl(b.cpu_time_delta, 0),
                    e.cpu_time_total - nvl(b.cpu_time_total, 0)) / 1000000,
             1)>100
 order by cpu_time desc;
 
 
 51572 51573 1 2398208476
 
 未绑定变量的高消耗语句：
col SIGNATURE foramt a10
 select aa.*, bb.sql_text
  from (select *
          from (select PARSING_SCHEMA_NAME,
                       sql_id,
                       to_char(FORCE_MATCHING_SIGNATURE) SIGNATURE,
                       sum(EXECUTIONS_DELTA),
                       sum(BUFFER_GETS_DELTA) tol,
                       decode(sum(EXECUTIONS_DELTA),
                              0,
                              sum(BUFFER_GETS_DELTA),
                              round(sum(BUFFER_GETS_DELTA) /
                                    sum(EXECUTIONS_DELTA),
                                    0)) gets_one_time
                  from dba_hist_sqlstat
                 where dbid = 2660478239
                   and snap_id between 19305 and 19307
                   and instance_number = 3
                 group by PARSING_SCHEMA_NAME,
                          sql_id,
                          to_char(FORCE_MATCHING_SIGNATURE)
                 order by sum(BUFFER_GETS_DELTA) desc)
         where rownum < 101) aa,
       dba_hist_sqltext bb
 where aa.sql_id = bb.sql_id 
 order by aa.tol desc

select * from dba_hist_snapshots;

round(sum(BUFFER_GETS_DELTA) /sum(EXECUTIONS_DELTA),0)) 
----------一块有多少行----------
select 'B' tbl_name,rows_per_block,count(*) number_of_sun_blocks from
(
select dbms_rowid.rowid_block_number(rowid),count(*) rows_per_block
from b group by dbms_rowid.rowid_block_number(rowid)
)
group by 'B',rows_per_block;
修改块中的行数
alter table b minimize records_per_block;

select sql_id,trunc(a.CPU_TIME/a.EXECUTIONS/1000),trunc(a.BUFFER_GETS/a.EXECUTIONS),a.EXECUTIONS, sql_text,LAST_ACTIVE_TIME,a.LAST_LOAD_TIME
  from gv$sqlarea a
 where sql_text like
       'SELECT * FROM ( SELECT ROW_.*, ROWNUM ROWNUM_ FROM ( SELECT p.PROCESS_ID, p.PROCESS_TYPE, p.PROCESS_NAME, p.Activity_Req_Process_Id, p.APP_NO, p.MAIN_APP_NO, p.BUSI_NO, p.BUSI_NAME, p.REMARK, c.ACTIVITY_ID,%'
   and a.LAST_ACTIVE_TIME > sysdate - 0.4 and a.INST_ID=2
   order by a.CPU_TIME/a.EXECUTIONS


select sql_id,trunc(a.CPU_TIME/a.EXECUTIONS/1000),trunc(a.BUFFER_GETS/a.EXECUTIONS),a.EXECUTIONS, sql_text,LAST_ACTIVE_TIME,a.LAST_LOAD_TIME
  from gv$sqlarea a
 where  a.LAST_ACTIVE_TIME > sysdate - 0.2 and a.INST_ID=2 and trunc(a.BUFFER_GETS/a.EXECUTIONS)>10000 and a.EXECUTIONS>0
   order by a.CPU_TIME/a.EXECUTIONS
   
exec dbms_stats.GATHER_TABLE_STATS('SGPMS','A_RCVBL_ENTRY',estimate_percent=>5,degree=>16);
exec dbms_stats.GATHER_INDEX_STATS('SGPMS','IND_A_RCVBL_ENTRY_ACCT_YM',estimate_percent=>20,degree=>8);
exec dbms_stats.GATHER_INDEX_STATS('SGPMS','IND_S_BATCH_CUST_APP_ON',estimate_percent=>5,degree=>8);
exec dbms_stats.GATHER_INDEX_STATS('SGPMS','IND_TEST_CONS_NO',estimate_percent=>5,degree=>8);
exec dbms_stats.GATHER_INDEX_STATS('SGPMS','PK_S_BATCH_CUST_APP',estimate_percent=>5,degree=>8);
exec dbms_stats.GATHER_TABLE_STATS('SGPMS','S_REGION_OUTAGE',estimate_percent=>5,cascade=>true,degree=>8);
exec dbms_stats.GATHER_INDEX_STATS('SGPMS','IND_S_APP_APP_NO',estimate_percent=>5,degree=>8);
exec dbms_stats.GATHER_INDEX_STATS('SGPMS','IND_S_APP_CONS_NO',estimate_percent=>5,degree=>8);
exec dbms_stats.GATHER_INDEX_STATS('SGPMS','IND_S_APP_CUST_ID',estimate_percent=>5,degree=>8);
exec dbms_stats.GATHER_INDEX_STATS('SGPMS','IND_S_APP_ON',estimate_percent=>5,degree=>8);
exec dbms_stats.GATHER_INDEX_STATS('SGPMS','PK_S_APP',estimate_percent=>5,degree=>8);

 from sgpms.S_REGION_OUTAGE R,  sgpms.PUB_S_REGION_OUTAGE K,  sgpms.S_PUBINFO_ARRANGE P
         where R.poweroff_id = K.poweroff_id
           and P.info_id = R.info_id
           and K.id = (select max(c.id)
                         from  sgpms.PUB_S_REGION_OUTAGE c
                        where c.poweroff_id = R.poweroff_id)
           AND R.ORG_NO LIKE '43412%'
select * from dba_indexes where table_name='

analyze table sgpms.S_REGION_OUTAGE compute statistics;
analyze table sgpms.PUB_S_REGION_OUTAGE compute statistics;
analyze table sgpms.S_PUBINFO_ARRANGE compute statistics;
analyze table sgpms.PUB_S_REGION_OUTAGE compute statistis;
修改事务槽
 alter table SCYW.T_ZH_ZTJX_PDSBBJPJJG iniTRANS 64
 
alter table cache02.E_MP_DAY_READ initrans 64;
alter table cache02.E_MP_DAY_READ parallel 4;
ALTER INDEX cache02.PK_E_MP_DAY_READ initrans 64;
alter INDEX cache02.PK_E_MP_DAY_READ parallel 4;
 
 select/*+rule*/ sql_id,trunc(a.CPU_TIME/a.EXECUTIONS/1000),trunc(a.BUFFER_GETS/a.EXECUTIONS),a.EXECUTIONS,LAST_ACTIVE_TIME,a.LAST_LOAD_TIME
  from v$sqlarea a
 where  a.LAST_ACTIVE_TIME > sysdate - 0.2 and sql_id='0c4zhjs691mtw';
 
 
 select sql_id,trunc(a.CPU_TIME/a.EXECUTIONS/1000),trunc(a.BUFFER_GETS/a.EXECUTIONS),a.EXECUTIONS,a.sql_text,LAST_ACTIVE_TIME,a.LAST_LOAD_TIME
  from v$sqlarea a
 where  a.LAST_ACTIVE_TIME > sysdate - 0.15 and trunc(a.BUFFER_GETS/a.EXECUTIONS)>50000 and a.EXECUTIONS>0 order by  trunc(a.BUFFER_GETS/a.EXECUTIONS) asc
 
select 'select sql_text from v$sqlarea where sql_id='''||sql_id||''';' from v$session where wait_class<>'Idle' order by sql_id ;

未绑定变量的高消耗的SQL语句
 select substr(sql_text,1,60),count(*)  from 
(
 select sql_text 
  from v$sqlarea a
 where  a.LAST_ACTIVE_TIME > sysdate - 0.3 and trunc(a.BUFFER_GETS/a.EXECUTIONS)>50000 
 and a.EXECUTIONS>0 order by  trunc(a.BUFFER_GETS/a.EXECUTIONS) asc 
)a group by substr(sql_text,1,60) having count(*) >10

select sql_id,sql_fulltext,buffer_gets,executions,a.LAST_LOAD_TIME from v$sqlarea a where sql_text like 'SELECT MP_NO, MP_NAME, SWITCH_NO, LINE_ID, TG_ID, VOLT_CODE%'
and buffer_gets>20002 and LAST_LOAD_TIME>sysdate-0.3;
添加service 
srvctl add service -d sgrcapdb -s tests -r sgrcapdb1 -a sgrcapdb2 -P basic -e select -m basic -z 180 -w 5
srvctl start service -d sgrcapdb -s tests


haip 
查看网络情况
oifcfg getif
oficfg iflist
oifcfg delif -global ib0/192.168.50.0:cluster_interconnect
oifcfg setif -global ib1/192.168.51.0:cluster_interconnect 

oifcfg delif -global ib1/192.168.51.0:cluster_interconnect

ib1  192.168.51.0

oifcfg setif -global ib0/192.168.50.0:cluster_interconnect 
绑定执行计划：
select a.* from table(dbms_xplan.display_cursor('bq1bdjj20r106',null,'ADVANCED'))a
@coe.sql
col SIGNATURE format 9999999999999999999999999
set linesize 150
set wra off
set long 99999
select * from dba_sql_profiles;
sys.sqlprof$attr
select * from sys.sqlprof$attr where SIGNATURE='9999001371278009501';
select * from sys.sqlprof$attr where SIGNATURE='&1';
exec DBMS_SQLTUNE.DROP_SQL_PROFILE('SYS_SQLPROF_03600fecfbdb0003');

asm实例常用命令：
1. select name,path,failgroup,mount_status,GROUP_NUMBER from v$asm_disk order by name,FAILGROUP;
2. alter diskgroup xxx drop disk 'xxx_name' reblance power 10;
3. create diskgroup xxx normal redundancy 
   failgroup xx disk '/dev/asm-disk4','/dev/asm-disk5'
   failgroup xx disk '/dev/asm-disk6','/dev/asm-disk7'
   attribute 'compatible.rdbms'='11.2','compatible.asm'='11.2';
   

create diskgroup datadgm normal redundancy 
   failgroup fdatam1 disk '/dev/mapper/mpathayp2','/dev/mapper/mpathaxp2'
   failgroup fdatam2 disk '/dev/mapper/c2s6','/dev/mapper/c2s7'
   attribute 'compatible.rdbms'='11.2.0.2','compatible.asm'='11.2.0.2';

create diskgroup datadgm normal redundancy 
   failgroup fdatam1 disk '/dev/mapper/c2s7'
   failgroup fdatam2 disk '/dev/mapper/c2s6'
   attribute 'compatible.rdbms'='11.2.0.2','compatible.asm'='11.2.0.2';

create diskgroup datadgm normal redundancy 
   failgroup fdatam1 disk '/dev/mapper/mpathayp2'
   failgroup fdatam2 disk '/dev/mapper/mpathaxp2'
   attribute 'compatible.rdbms'='11.2.0.2','compatible.asm'='11.2.0.2';
alter diskgroup datadgm add failgroup fdatam3 '/dev/mapper/c2s6';

   
3. create diskgroup xxx external redundancy 
   disk '/dev/asm-disk4','/dev/asm-disk5'
   attribute 'compatible.rdbms'='11.2','compatible.asm'='11.2';

select * from v$asm_ATTRIBUTE where name='disk_repair_time';
select GROUP_NUMBER,NAME,VALUE from v$asm_ATTRIBUTE  where name='disk_repair_time';

4. alter diskgroup xxx online disk 'xxxx_aa';

alter diskgroup FIODG online disks in failgroup FIOSTO4 ;
alter diskgroup ARCHDG online disks in failgroup ARCHSTO4;
alter diskgroup REDODG online disks in failgroup REDOSTO4;

select GROUP_NUMBER,STATE,NAME,FAILGROUP,PATH from v$asm_disk where FAILGROUP like 'PMDBDATA_FG%' order by PATH
select * from v$asm_
select * from v$asm_ATTRIBUTE where name='disk_repair_time';
select GROUP_NUMBER,NAME,VALUE from v$asm_ATTRIBUTE  where name='disk_repair_time';
找sql--

 XID 23.38.7515287
  22.3.7414126
col start_time format a20
col LAST_UPDATE_TIME format a30
col message format a20
select inst_id,sid,(SOFAR/TOTALWORK)*100,START_TIME,LAST_UPDATE_TIME,TIME_REMAINING,ELAPSED_SECONDS from gv$session_longops where TIME_REMAINING>0;

ASM 修改密码：
orapwusr --modify --password sys
AsmGrd022

营销调整：
exec dbms_stats.set_table_prefs('SGPMS','WF_PROCESS','ESTIMATE_PERCENT',20);
exec dbms_stats.set_table_prefs('SGPMS','WF_ASSIGNMENT_END','ESTIMATE_PERCENT',20);
exec dbms_stats.set_table_prefs('SGPMS','WF_ACTIVITY','ESTIMATE_PERCENT',20);
select  dbms_stats.get_prefs('ESTIMATE_PERCENT',NULL,'WF_ACTIVITY') FROM DUAL ;

修改统计信息收集比例：
exec dbms_stats.set_table_prefs('SGPMS','WF_PROCESS','STALE_PERCENT',1);
exec dbms_stats.set_table_prefs('SGPMS','WF_ASSIGNMENT_END','STALE_PERCENT',1);
exec dbms_stats.set_table_prefs('SGPMS','WF_ACTIVITY','STALE_PERCENT',1);
select  dbms_stats.get_prefs('STALE_PERCENT','SGPMS','WF_ACTIVITY') FROM DUAL ;

错误的方向造成分析结果延误：
应该首先拿awr报告。！

 execute dbms_stats.gather_table_stats(ownname => 'GWDLDXPT', tabname =>'TD_SMSS_RPT_SYSTEM_DONE', estimate_percent =>10,cascade => TRUE,degree=>16);
 
索引损坏：dbms_repair.online_index_clean修复
vm.nr_hugepages =  32768
declare 
done boolean;
begin
done:=dbms_repair.online_index_clean(132952);
end;
/
              
临时段使用情况查询 :
SELECT c.sql_fulltext,a.username, a.sid, a.serial#, a.osuser, b.tablespace, b.blocks
FROM v$session a, v$sort_usage b, v$sqlarea c                                    
WHERE a.saddr = b.session_addr                                                   
AND c.address= a.sql_address                                                     
AND c.hash_value = a.sql_hash_value                                              
ORDER BY b.blocks,b.tablespace;                                                 
                                                                                 
For 10.1 and above:        
set linesize 180
set long 9999
set wra on                                                   
col  username format a10
col osuser format a10
col  tablespace format a15
set pagesize 9999                                                  
SELECT c.sql_fulltext,a.username, a.sid, a.serial#, a.osuser,b.tablespace, b.blocks,b.session_addr
FROM v$session a, v$tempseg_usage b, v$sqlarea c                                 
WHERE a.saddr = b.session_addr                                                   
AND c.address= a.sql_address                                                     
AND c.hash_value = a.sql_hash_value                                
ORDER BY  b.blocks,b.tablespace;           

col USERNAME format a8
set linesize 160
col USER format a8
set wra off
col TABLESPACE format a8
col CONTENTS format a10
col  SEGFILE# format 9999
col SESSION_NUM format 99999
col extents format 9999
select * from  gv$tempseg_usage order by blocks;     
select sql_text from v$sqlarea where sql_id='7mx39hbp8vucj'               
set linesize 180
set long 9999
set wra on                                                   
col  username format a10
col osuser format a10
col  tablespace format a15
col machine format a15
col inst_id format 9999
set pagesize 9999    
create table templog as                                               
SELECT sysdate as dt,a.inst_id,b.sql_id bsql,a.sql_id asql,b.session_addr,a.username, a.sid, a.serial#,a.machine,a.osuser, b.tablespace, b.blocks
FROM gv$session a, gv$tempseg_usage b                                
WHERE a.saddr = b.session_addr   and a.inst_id=b.inst_id  and  b.blocks>1000                                                                                   
ORDER BY  a.inst_id,b.blocks,b.tablespace; 

set linesize 160
set long 9999
set wra on                                                   
col  username format a10
col osuser format a10
col  tablespace format a15
col machine format a15
set pagesize 9999                                                  
SELECT a.inst_id,b.SEGTYPE,a.sql_id ,b.session_addr,a.username, a.sid, a.serial#,a.machine,a.osuser, b.tablespace, b.blocks
FROM gv$session a, gv$tempseg_usage b                                
WHERE a.saddr = b.session_addr   and a.inst_id=b.inst_id  --and  b.blocks>4000                                                                                     
ORDER BY  b.blocks,b.tablespace

select sum(
set linesize 180
set long 9999
set wra on                                                   
col  username format a10
col osuser format a10
col  tablespace format a15
col machine format a15
set pagesize 9999                                                  
SELECT 'alter system kill session '''||a.sid||','||a.serial#||''';'
FROM v$session a, v$tempseg_usage b                                
WHERE a.saddr = b.session_addr     and  b.blocks>50000                                                                                       
ORDER BY  b.blocks,b.tablespace

select * from gv$sort_segment

select LAST_ANALYZED,table_name,SUBPARTITION_NAME from dba_tab_subpartitions 
where SUBPARTITION_NAME like '%1608%'
and TABLE_OWNER='SGPMS' AND LAST_ANALYZED<SYSDATE-6 and table_name<>'A_PC_TRAN' 
and SUBPARTITION_NAME not like '%MAXVL%';

select * from templog order by session_addr,inst_id,dt

select table_name from dba_tab_columns  where 


 select sql_id,TEMP_SPACE_ALLOCATED,SAMPLE_TIME,IN_JAVA_EXECUTION from dba_hist_active_sess_history where SESSION_ID='12912' and  
 SESSION_SERIAL#='195' and  SAMPLE_TIME>sysdate-7
 
 select sql_text from dba_hist_sqltext where sql_id='&1';
 

col USERNAME format a8
set linesize 160
col USER format a8
set wra off
col TABLESPACE format a8
col CONTENTS format a10
col  SEGFILE# format 9999
col SESSION_NUM format 99999
col extents format 9999
select * from  v$tempseg_usage where username='SYS' order by blocks ; 

直方图：
select * from sys.col_usage$ where obj#=154382;
.a_pay_flow
select object_id from dba_objects where object_name='A_PAY_FLOW' AND OBJECT_TYPE='TABLE';
dbms_stats.flush_database_monitoring_info;(刷新内存数据到表）

select * from dba_tab_histograms where table_name='R_ATTR_MAINT' and owner='SGPMS' and column_name='NEW_VALUE' order by ENDPOINT_NUMBER ;
select * from dba_tab_col_statistics where table_name='R_ATTR_MAINT' and owner='SGPMS';
select count(*) from sgpms.R_ATTR_MAINT where NEW_VALUE='02';
exec dbms_stats.GATHER_TABLE_STATS('SGPMS','R_ATTR_MAINT',estimate_percent=>20,cascade=>true,method_opt=>'FOR ALL COLUMNS SIZE AUTO',degree=>8);

确定crs状态：
确定集群状态
crsctl check crs
crsctl check crs
crsctl stat res -t -init
crsctl stat res -t
ps -ef|egrep 'init|d.bin'

crsctl start resource  ora.crsd -init
crsctl stop resource  ora.crsd -init

内存抖动视图：
sga_resize_ops
col COMPONENT format a30
col PARAMETER format a20
set linesize 180
alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
select * from gv$sga_resize_ops

C:\Documents and Settings\All Users\Application Data\Oracle\Java\javapath;D:\oracle\product\11.2.0\dbhome_2\bin;C:\Program Files (x86)\Common Files\NetSarang;C:\Perl64\site\bin;C:\Perl64\bin;%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;C:\usr\bin;%JAVA_HOME%\bin

declare
done boolean;
begin
done:=dbms_repair.online_index_clean(132952);
end;
/
高水位线查询：
col SEGMENT_NAME format a30 
col OWNER forma a20
col FILE_ID format  999999999
col PARTITION_NAME format a30
col TABLESPACE_NAME format a30
set linesize 150
set wra off
select a.SEGMENT_NAME,a.OWNER,a.FILE_ID,a.PARTITION_NAME,a.TABLESPACE_NAME
from dba_extents a,
(select max(BLOCK_ID) BLOCK_ID,FILE_ID from dba_extents group by FILE_ID) b
where a.BLOCK_ID=b.BLOCK_ID and a.FILE_ID=b.FILE_ID  and a.tablespace_name='TS_MLOG' order by FILE_ID

file 18, block 764194
alter table table_name enable row movement;

alter table table_name modify subpartition partition_name shrink space;


查询补丁：
set wra off
set linesize 150
col ACTION_TIME format a20
col ACTION format a10
col NAMESPACE format a20
col VERSION format a10 
select * from dba_registry_history


dbms_shared_pool.purge
SQL> select address,hash_value||'' from v$sqlarea where sql_id='3jptsv2bs0wm7';

ADDRESS          HASH_VALUE||''
---------------- ----------------------------------------
0000002DB9F40018 1141605382

SQL> exec sys.dbms_shared_pool.purge('0000000A66B0FB08,2541777511','c');

select 'exec sys.dbms_shared_pool.purge('''||address||','||hash_value||''','||'''c'');' from v$sqlarea where sql_id='&1';
f8wk7b6n7427a
286ydbf6dm0zc

查询快照中的数据：
select * from (select * from SCYW.T_SB_ZWYC_ZSBYQ  as of scn 15171737841721) a where a.xh='9853928074';

查询version_startscn
col  versions_startscn format 999999999999999999999
select versions_startscn,to_char(versions_starttime,'yyyy-mm-dd hh24:mi:ss'),versions_operation,
MANDT,Z00HRJYFBH,Z00HRJYGBH,Z00HRJFLXMBH,BELNR
 from sapsr3.ZSGETVTFLZFHC
versions between scn 14146012172113 and 14146012172999 where 1=1 and versions_startscn is not null 
order by versions_startscn desc;
col a format 9999999999999999999999999999
select * from (select timestamp_to_scn(to_date('2018-07-12 09:48:00','yyyy-mm-dd hh24:mi:ss')) a from dual) a ;

col a format 9999999999999999999999999999
select * from (select timestamp_to_scn(to_date('2016-12-19 14:41:00','yyyy-mm-dd hh24:mi:ss')) a from dual) a ;
ZSGETVTFLZFHC

select count(*) from sgpms.c_cons as of scn 15311333033318;
用户权限：
dba_role_privs
dba_sys_privs
Zzsfp!Root-081
hepc-.081
select username,wmsys.wm_concat(GRANTED_ROLE)
from 
(
select username,GRANTED_ROLE from dba_role_privs a,dba_users b where a.GRANTEE=b.username and b.ACCOUNT_STATUS='OPEN' 
and username in (upper('&1')) 
union all
select GRANTEE, PRIVILEGE from dba_sys_privs where GRANTEE in(select username from dba_users where ACCOUNT_STATUS='OPEN' 
and username in (upper('&1')))
) a  group by username ;
select username,wmsys.wm_concat(GRANTED_ROLE)
from 
(
select username,GRANTED_ROLE from dba_role_privs a,dba_users b where a.GRANTEE=b.username and b.ACCOUNT_STATUS='OPEN' and username not in('SYS','SYSTEM')
union all
select GRANTEE, PRIVILEGE from dba_sys_privs where GRANTEE in(select username from dba_users where ACCOUNT_STATUS='OPEN') and GRANTEE not in('SYS','SYSTEM')
) a  group by username 


补充漏洞：
select distinct GRANTED_ROLE from
(
(select GRANTED_ROLE from dba_role_privs a,dba_users b where a.GRANTEE=b.username and b.ACCOUNT_STATUS='OPEN') 
union all
(select PRIVILEGE from dba_sys_privs where GRANTEE in(select username from dba_users where ACCOUNT_STATUS='OPEN'))
union all
(select PRIVILEGE from dba_sys_privs where GRANTEE in (select GRANTED_ROLE from  dba_role_privs a,dba_users b where a.GRANTEE=b.username and b.ACCOUNT_STATUS='OPEN'))
)



select username,GRANTED_ROLE from dba_role_privs a,dba_users b where a.GRANTEE=b.username and b.ACCOUNT_STATUS='OPEN' 
and username  in ('Z_XT_FICO') 
union all
select GRANTEE, PRIVILEGE from dba_sys_privs where GRANTEE in(select username from dba_users where ACCOUNT_STATUS='OPEN' 
and username in ('Z_XT_FICO'))


select * from dba_sys_privs where GRANTEE in(select username from dba_users where ACCOUNT_STATUS='OPEN' 
and username not in ('SYS','SYSTEM')) and (PRIVILEGE like 'IMP%' or PRIVILEGE like 'EXP%' or PRIVILEGE like 'IMP%' or PRIVILEGE like  '%TABLESPACE%' or PRIVILEGE like 'DROP ANY%')
order by GRANTEE
select username,GRANTED_ROLE,CREATED from dba_role_privs a,dba_users b where a.GRANTEE=b.username and b.ACCOUNT_STATUS='OPEN' 
and username not in ('SYS','SYSTEM')  and GRANTED_ROLE ='DBA'

select username,GRANTED_ROLE from dba_role_privs a,dba_users b where a.GRANTEE=b.username 
and username not in ('SYS','SYSTEM')  and GRANTED_ROLE ='DBA'

select username from dba_role_privs a,dba_users b where a.GRANTEE=b.username and b.ACCOUNT_STATUS='OPEN' 
and username not in ('SYS','SYSTEM')  and GRANTED_ROLE ='DBA';

select username from dba_role_privs a,dba_users b where a.GRANTEE=b.username and b.ACCOUNT_STATUS='OPEN' 
 and GRANTED_ROLE ='DBA';
set wra off
col RESOURCE_NAME format a40
col PROFILE format a40
set linesize 150
select * from dba_profiles;


select username,GRANTED_ROLE
from 
(
select username,GRANTED_ROLE from dba_role_privs a,dba_users b where a.GRANTEE=b.username and b.ACCOUNT_STATUS='OPEN' 
and username not in ('SYS','SYSTEM') 
union all
select GRANTEE, PRIVILEGE from dba_sys_privs where GRANTEE in(select username from dba_users where ACCOUNT_STATUS='OPEN' 
and username not in ('SYS','SYSTEM')) order by username
) a  group by username 

select 
to_char(b.end_interval_time,'yyyymmddhh24mi'),
sum(BUFFER_GETS_DELTA),
sum(ELAPSED_TIME_DELTA)/1000000,
sum(DISK_READS_DELTA),
sum(EXECUTIONS_DELTA),
sum(DISK_READS_DELTA)
from 
dba_hist_sqlstat a,
dba_hist_snapshot b
where a.snap_id=b.snap_id
  and a.instance_number=b.instance_number
 and sql_id='&1'
 and b.end_interval_time>sysdate-2
 group by to_char(b.end_interval_time,'yyyymmddhh24mi') order by 1;


长时间执行执行的执行计划变分析：
col sum(ELAPSED_TIME_DELTA) format 999999999999999999
col sum(EXECUTIONS_DELTA) format 99999999999999999
select trunc((sum(ELAPSED_TIME_DELTA)/sum(EXECUTIONS_DELTA))/1000000),trunc(sum(ELAPSED_TIME_DELTA)/1000000),trunc(sum(EXECUTIONS_DELTA)),PLAN_HASH_VALUE,sql_id from 
dba_hist_sqlstat a,
dba_hist_snapshot b
where a.sql_id='&1' 
and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
and b.end_interval_time>sysdate-10
group by PLAN_HASH_VALUE,sql_id



select INSTANCE_NUMBER,b.sql_text from dba_hist_active_sess_history a,dba_hist_sqltext b
where SAMPLE_TIME>to_date('2017-06-16 09:28:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2017-06-16 10:30:00','yyyy-mm-dd hh24:mi:ss')
and a.sql_id=b.sql_id

select INSTANCE_NUMBER,b.sql_text from dba_hist_active_sess_history a,dba_hist_sqltext b
where SAMPLE_TIME>to_date('2016-12-20 16:15:00','yyyy-mm-dd hh24:mi:ss')
and SAMPLE_TIME<to_date('2016-12-20 16:30:00','yyyy-mm-dd hh24:mi:ss')
and a.sql_id=b.sql_id


dba_hist_active_sess_history 
select count(*),to_char(sample_time,'yyyy-mm-dd hh24:mi'),INSTANCE_NUMBER from dba_hist_active_sess_history
where sample_time>sysdate-1 and sql_id='0v17nh992bvyd' group by to_char(sample_time,'yyyy-mm-dd hh24:mi'),INSTANCE_NUMBER
order by 2
查询用户被锁时间！
alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
select name,ltime from user$ where name='&1';
 Pmht-.20
 23-FEB-2017 15:59:14
 
 2017-08-21 10:10:06
比特币注入攻击：
select  owner,TRIGGER_NAME  from dba_triggers where
TRIGGER_NAME like 'DBMS_%_INTERNAL% '
union all
select  owner,a.object_name from dba_procedures a 
where a.object_name like 'DBMS_%_INTERNAL% ';

查看索引是全球还是本地索引。

select locality,index_name from dba_part_indexes where index_name='PK_E_PL_AMT';

scn参数:调整：

查询隐含参数：
 
SELECT I.KSPPINM NAME,       
       CV.KSPPSTVL VALUE
  FROM SYS.X$KSPPI I, SYS.X$KSPPCV CV
 WHERE I.INST_ID = USERENV('Instance')
   AND CV.INST_ID = USERENV('Instance')
   AND I.INDX = CV.INDX
   AND I.KSPPINM LIKE '/_fix_control%'
 ESCAPE '/';

 
SELECT I.KSPPINM NAME,       
       CV.KSPPSTVL VALUE
  FROM SYS.X$KSPPI I, SYS.X$KSPPCV CV
 WHERE I.INST_ID = USERENV('Instance')
   AND CV.INST_ID = USERENV('Instance')
   AND I.INDX = CV.INDX
   AND I.KSPPINM LIKE '/_fix_control%'
 ESCAPE '/';


select version,
       date_time,
       dbms_flashback.get_system_change_number current_scn,
       headroom
  from (select version,
               to_char(SYSDATE, 'YYYY/MM/DD HH24:MI:SS') DATE_TIME,
               ((((((to_number(to_char(sysdate, 'YYYY')) - 1988) * 12 * 31 * 24 * 60 * 60) +
               ((to_number(to_char(sysdate, 'MM')) - 1) * 31 * 24 * 60 * 60) +
               (((to_number(to_char(sysdate, 'DD')) - 1)) * 24 * 60 * 60) +
               (to_number(to_char(sysdate, 'HH24')) * 60 * 60) +
               (to_number(to_char(sysdate, 'MI')) * 60) +
               (to_number(to_char(sysdate, 'SS')))) * (16 * 1024)) -
               dbms_flashback.get_system_change_number) /
               (16 * 1024 * 60 * 60 * 24)) headroom
          from v$instance);
          

asm磁盘：

set linesize 150
set pagesize 9999
col DISK format 9999
col A.NAME format a20
col NUMBER_KFDPARTNER 99999
col C.NAME format 320
col PARITY_KFDPARTNER 9999
col ACTIVE_KFDPARTNER 9999
SELECT DISK,A.NAME,NUMBER_KFDPARTNER,C.NAME,PARITY_KFDPARTNER,ACTIVE_KFDPARTNER
FROM
X$KFDPARTNER X,
V$ASM_DISK A,
(SELECT DISK_NUMBER,NAME FROM V$ASM_DISK WHERE GROUP_NUMBER=4) C
WHERE GRP=4
AND A.DISK_NUMBER=30
AND X.GRP=A.GROUP_NUMBER
AND X.DISK=A.DISK_NUMBER
AND X.NUMBER_KFDPARTNER=C.DISK_NUMBER
ORDER BY DISK,NUMBER_KFDPARTNER
/


查询SHARED_POOL 
chunk自由情况：

break on ksmchidx on ksmchdur  
select  
  ksmchidx,ksmchdur,  
  case  
        when ksmchsiz < 1672 then trunc((ksmchsiz-32)/8)  
        when ksmchsiz < 4120 then trunc((ksmchsiz+7928)/48)  
        when ksmchsiz < 8216 then 250  
        when ksmchsiz < 16408 then 251  
        when ksmchsiz < 32792 then 252  
        when ksmchsiz < 65560 then 253  
        when ksmchsiz >= 65560 then 253  
   end bucket,  
  sum(ksmchsiz)  free_space,  
  count(*)  free_chunks,  
  trunc(avg(ksmchsiz))  average_size,  
  max(ksmchsiz)  biggest  
from  
  sys.x$ksmsp  
where  
  inst_id = userenv('Instance') and  
  ksmchcls = 'free'  
group by  
  case  
        when ksmchsiz < 1672 then trunc((ksmchsiz-32)/8)  
        when ksmchsiz < 4120 then trunc((ksmchsiz+7928)/48)  
        when ksmchsiz < 8216 then 250  
        when ksmchsiz < 16408 then 251  
        when ksmchsiz < 32792 then 252  
        when ksmchsiz < 65560 then 253  
        when ksmchsiz >= 65560 then 253  
   end ,  
  ksmchidx, ksmchdur  
  having   max(ksmchsiz)>3192
order by ksmchidx , ksmchdur  
/  


---
 select sum(bytes)/1024/1024 mb from v$sgastat where pool='shared pool';

------ 
SELECT KSMCHCLS CLASS, COUNT(KSMCHCLS) NUM, SUM(KSMCHSIZ)  SIZ,  
To_char( ((SUM(KSMCHSIZ)/COUNT(KSMCHCLS)/1024)),'999,999.00')||'k' "AVG SIZE"  
FROM X$KSMSP GROUP BY KSMCHCLS;   


scn：授权
revoke dba from dbmt;
grant select any dictionary to dbmt;
grant connect to dbmt;
grant select on DBA_HIST_sysstat to dbmt;
grant select on DBA_HIST_snapshot to dbmt;
grant select on dba_hist_wr_control to dbmt;
grant select on x$_ksppi to dbmt;
grant select on x$_ksppcv to dbmt;
grant select any dictionary to dbmt;
create view canway$ksppi as select * from x$ksppi;
create public synonym x$_ksppi for canway$ksppi;
grant select on x$_ksppi to dbmt;
create view canway$ksppcv as select * from x$ksppcv;
create public synonym x$_ksppcv for canway$ksppcv;  

替换dba较色：

set pagesize 9999
set linesize 160
set wra off
spool /tmp/gr.sql
select 'grant '||PRIVILEGE||' to goldengate;' from dba_sys_privs where grantee='DBA'
union all 
SELECT 'grant '||GRANTED_ROLE||' to goldengate;' FROM DBA_ROLE_PRIVS WHERE GRANTEE='DBA';
spool off



rman -备份恢复
--根据scn号确定时间
select to_char(scn_to_timestamp(15214741871685),'yyyy-mm-dd hh24:mi:ss') from dual;

A_VOUCHER_CWGK 
bplist -C hncoaa2 -t 4 -s 2015-07-01 -e 2015-12-01 -R /


C:\Program Files\Veritas\Volmgr\bin

bpimmedia -mediaid 0119L4

--查询最小开库需要的scn
select min(FHSCN),max(FHSCN),max(FHAFS) from x$kcvfh;

--查看rman备份
set lines 400 
set pages 200 
set echo off 
set verify off 
set scan on 
col TIME_TAKEN_DISPLAY for a8 
col "INPUT(SUM)" for a9 
col "OUTPUT(SUM)" for a10 
col status for a9 
col "INPUT(s)" for a9 
col "OUTPUT(s)" for a9 
col OUTPUT_DEVICE_TYPE for a5 
col INPUT_TYPE for a7 
col start_time for a20 
col end_time for a20 
SELECT session_key, 
TO_CHAR (START_TIME, 'yyyy-mm-dd hh24:mi:ss') start_time, 
TO_CHAR (end_time, 'yyyy-mm-dd hh24:mi:ss') end_time, 
TIME_TAKEN_DISPLAY, 
INPUT_BYTES_DISPLAY "INPUT(SUM)", 
OUTPUT_BYTES_DISPLAY "OUTPUT(SUM)", 
OUTPUT_DEVICE_TYPE, 
STATUS, 
INPUT_TYPE, 
INPUT_BYTES_PER_SEC_DISPLAY "INPUT(s)", 
OUTPUT_BYTES_PER_SEC_DISPLAY "OUTPUT(s)" 
FROM v$rman_backup_job_details 
order by session_key; 



LSNRCTL> set current_LISTENER LISTENER_SCAN1
Current Listener is LISTENER_SCAN1

--NBU优化参数
[root@]# echo 32 > /usr/openv/netbackup/db/config/NUMBER_DATA_BUFFERS     
         echo 262144 > /usr/openv/netbackup/db/config/SIZE_DATA_BUFFERS  

vmoprcmd -d

--NBU起驱动器
vmoprcmd -up 1 

--NBU驱动器状态pend


--NBU （HP查看驱动器链接）
ioscan -fnCtape
--NBU状态 required media is in use
处理：空闲磁带不够，重新分配磁带即可
--nbu查看磁带信息
bpmedialist -m 0005L5
--nbu清空磁带数据
bpexpdate -m 0242L5 -d 0
--查看impdp进度
set linesize 1200
set pagesize 9999
col target for a10
col onwer_name for a10
col job_name for a10
col state for a15
col message for a60
col "pree%" for a7
select a.sid,a.serial#,a.target,a.sofar,a.totalwork,round(a.sofar/a.totalwork*100,2)||'%' as "pree%" ,
       a.start_time,a.timestamp,a.context,a.message,a.time_remaining,a.elapsed_seconds,b.session_type,c.owner_name,c.job_name,c.state
       from v$session_longops a,dba_datapump_sessions b,dba_datapump_jobs c,v$session d
            where a.sid=d.sid and a.serial#=d.serial# and d.saddr=b.saddr and b.job_name=c.job_name;

--nbu查看磁带备份内容
 bpimmedia -mediaid 0198L5

--nbu清缓存
[root@tnfs bin]# ./bpclntcmd -clear_host_cache
[root@tnfs bin]# pwd
/usr/openv/netbackup/bin

物化视图：
select * from dba_registered_mviews;


segment 变化查询：
set heading on
set 搜索linesize 5500
SELECT TO_CHAR (sp.begin_interval_time,'DD-MM-YYYY') days
    , ts.tsname
    , max(round((tsu.tablespace_size* dt.block_size )/(1024*1024),2) ) cur_size_MB
    , max(round((tsu.tablespace_usedsize* dt.block_size )/(1024*1024),2)) usedsize_MB
    FROM DBA_HIST_TBSPC_SPACE_USAGE tsu
    , DBA_HIST_TABLESPACE_STAT ts
    , DBA_HIST_SNAPSHOT sp
    , DBA_TABLESPACES dt
    WHERE tsu.tablespace_id= ts.ts#
   AND tsu.snap_id = sp.snap_id
   AND ts.tsname = dt.tablespace_name
   AND ts.tsname NOT IN ('SYSAUX','SYSTEM')
   GROUP BY TO_CHAR (sp.begin_interval_time,'DD-MM-YYYY'), ts.tsname
   ORDER BY ts.tsname, days;

set feedback on
--and c.owner ='&owner'

select * from (select c.segment_name "Object Name",b.object_type,
sum(space_used_delta)/1024/1024 "Growth (MB)"
from dba_hist_snapshot sn,
dba_hist_seg_stat a,
dba_objects b,
dba_segments c
where begin_interval_time > trunc(sysdate)
and sn.snap_id = a.snap_id
and b.object_id = a.obj#
and b.owner = c.owner
and b.object_name = c.segment_name
group by c.segment_name,b.object_type)
order by 3 asc;

column "Percent of Total Disk Usage" justify right format 999.99
column "Space Used (MB)" justify right format 9,999,999.99
column "Total Object Size (MB)" justify right format 9,999,999.99
set linesize 150
set pages 80
set feedback off

set line 5000
column "SEGMENT_NAME" justify left format A30
column "TABLESPACE_NAME" justify left format A30
select * from (select c.segment_name,to_char(end_interval_time, 'MM/DD/YY') mydate, 
sum(space_used_delta)/1024/1024 "Space used (MB)", avg(c.bytes)/1024/1024 "Total Object Size (MB)",
round(sum(space_used_delta)/sum(c.bytes) * 100, 2) "Percent of Total Disk Usage"
from
dba_hist_snapshot sn,
dba_hist_seg_stat a,
dba_objects b,
dba_segments c
where begin_interval_time > trunc(sysdate)
and sn.snap_id = a.snap_id
and b.object_id = a.obj#
and b.owner = c.owner
and b.object_name = c.segment_name
group by c.segment_name,to_char(end_interval_time, 'MM/DD/YY')
order by avg(c.bytes)/1024/1024,c.segment_name,to_date(mydate, 'MM/DD/YY'));

创建监控账号：
grant select any dictionary to dbmnt;
grant connect to dbmnt;
grant select on DBA_HIST_sysstat to dbmnt;
grant select on DBA_HIST_snapshot to dbmnt;
grant select on dba_hist_wr_control to dbmnt;
grant select on x$_ksppi to dbmnt;
grant select on x$_ksppcv to dbmnt;
grant select any dictionary to dbmnt;
create view canway$ksppi as select * from x$ksppi;
create public synonym x$_ksppi for canway$ksppi;
grant select on x$_ksppi to dbmnt;
create view canway$ksppcv as select * from x$ksppcv;
create public synonym x$_ksppcv for canway$ksppcv; 
grant select any dictionary to dbmnt;
create user dbmnt identified by "Aim)*93db";

select * from dba_users where username like 'OGG%' or username like 'GOLD%' or username like 'DBM%' or username like 'HPS%';






Ora-.4304

select (t.total-t.free) used,TABLESPACE_NAME,t.free from (select a.TABLESPACE_NAME,a.total,b.free from
(select TABLESPACE_NAME, sum(BYTES) total from dba_data_files group by TABLESPACE_NAME) a left join
(select TABLESPACE_NAME, sum(BYTES) free from dba_free_space group by TABLESPACE_NAME) b
on a.TABLESPACE_NAME = b.TABLESPACE_NAME
union all
select TABLESPACE_NAME,sum(bytes) total,sum(29360128) free from dba_temp_files group by TABLESPACE_NAME) t
order by t.TABLESPACE_NAME

select round(a.total/1024/1204/1024,0) as total, TABLESPACE_NAME from (select TABLESPACE_NAME, sum(BYTES) total from dba_data_files group by TABLESPACE_NAME
union all select TABLESPACE_NAME, sum(BYTES) total from  dba_temp_files group by TABLESPACE_NAME) a order by a.TABLESPACE_NAME

dba_hist_tbspc_space_usage
dba_hist_seg_stat.
select TABLESPACE_SIZE,TABLESPACE_MAXSIZE,TABLESPACE_USEDSIZE ,SNAP_ID,RTIME from dba_hist_tbspc_space_usage where TABLESPACE_ID=5 order by RTIME

select userate,TABLESPACE from 
(SELECT a.tablespace_name,100 - trunc(((b.max_size_kb - (b.size_kb - a.free_kb)) /(b.max_size_kb)) * 100, 2) userate FROM 
 (SELECT tablespace_name, Trunc(Sum(bytes) / 1024) free_kb FROM dba_free_space GROUP BY tablespace_name) a,
 (SELECT tablespace_name, Trunc(Sum(decode(AUTOEXTENSIBLE,'NO',bytes,'YES',
                                        case
                                          when MAXBYTES <= bytes then
                                           bytes
                                          else
                                           MAXBYTES
                                        end)) / 1024) max_size_kb, trunc(sum(bytes) / 1024) size_kb FROM dba_data_files GROUP BY tablespace_name) b
  WHERE a.tablespace_name = b.tablespace_name
union 
  SELECT D.TABLESPACE_NAME, ROUND(NVL(USED_SPACE, 0) / SPACE * 100, 2) userate FROM 
  (SELECT TABLESPACE_NAME, ROUND(SUM(BYTES) / (1024 * 1024), 2) SPACE,SUM(BLOCKS) BLOCKS FROM DBA_TEMP_FILES GROUP BY TABLESPACE_NAME) D,
  (SELECT TABLESPACE_NAME, ROUND(SUM(BYTES_USED) / (1024 * 1024), 2) USED_SPACE, ROUND(SUM(BYTES_FREE) / (1024 * 1024), 2) FREE_SPACE FROM V$TEMP_SPACE_HEADER GROUP BY TABLESPACE_NAME) F
  WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME(+)) t
order by tablespace_name 


select (t.total-t.free) used from (select a.TABLESPACE_NAME,a.total,b.free from
(select TABLESPACE_NAME, sum(BYTES) total from dba_data_files group by TABLESPACE_NAME) a left join
(select TABLESPACE_NAME, sum(BYTES) free from dba_free_space group by TABLESPACE_NAME) b
on a.TABLESPACE_NAME = b.TABLESPACE_NAME AND a.TABLESPACE_NAME='USERS'
union all
select TABLESPACE_NAME,sum(bytes) total,sum(29360128) free from dba_temp_files group by TABLESPACE_NAME) t
order by t.TABLESPACE_NAME



TURBOCMS/Cms-.2017

-- Create table


alter system check datafile;

ora-01187 ora-01110

sysaux 分析
select dbms_stats.get_stats_history_retention from dual;
select sum(space_usage_kbytes) from v$sysaux_occupants;


              
exec dbms_stats.purge_stats(sysdate-1);    

truncate table I_WRI$_OPTSTAT_HH_OBJ_ICOL_ST;

select sum(bytes)/1024/1024,segment_name ,owner,segment_type from dba_segments where tablespace_name='SYSAUX' group by segment_name,owner,segment_type having sum(bytes)/1024/1024>10;

select 'alter database datafile '||file_id||' resize 20G;'  from dba_data_files where tablespace_name='SYSAUX' and BYTES/1024/1024/1024>30;

select sum(bytes)/1024/1024/1024,segment_name ,owner,segment_type from seg3  group by segment_name,owner,segment_type having sum(bytes)/1024/1024/1024>100;
col SEGMENT_NAME format a40
col PARTITION_NAME format a40
select/*+rule*/ max(block_id+blocks),file_id,SEGMENT_NAME,PARTITION_NAME from dba_extents where tablespace_name='SYSAUX' group by file_id,SEGMENT_NAME,PARTITION_NAME order by max(block_id+blocks);

注册归档：
catalog start with '+data/PSDSS/ARCHIVELOG/2018_10_30/'
while [ 1=1 ]
do 
rman target / catalog rman/Manr_4262@rman <<!
report unrecoverable;
exit;
!
sleep 30
done 
nologging


SQL> set time on
09:02:24 SQL> select sgpms.SEQ_CONTRACT_NO_43401.nextval from dual;

   NEXTVAL
----------
 314371933
 314556378
 
 CREATE SEQUENCE SGPMS.SEQ_CONTRACT_NO_43401

  START WITH 310000000
  MAXVALUE 319999999
  MINVALUE 310000000
  NOCYCLE
  CACHE 1000
  increment by 1
  NOORDER;
  
  c_cust_
  
select * from v$access where OBJECT='SEQ_CONTRACT_NO_43401';
  

set wra off
set linesize 150
select * from gv$access where OBJECT='SEQ_CONTRACT_NO_43402';

select max(SIGN_DATE),max(END_DATE),

alter session set "_optimizer_cartesian_enabled"=false;
select /*+rule*/ * from v$access where sid in(select sid from v$session where username='SGPMS');

序列跟踪 :
alter session set "_optimizer_cartesian_enabled"=false;


数据库字典检查
exec dbms_hm.run_check('Dictionary Integrity Check','my_run');
select dbms_hm.get_run_report('my_run') from dual;
select * from v$hm_recommendation;

统计信息查询：
select COST,CPU_COST,IO_COST,PLAN_HASH_VALUE,OBJECT_NAME,TIMESTAMP  from DBA_HIST_SQL_PLAN where sql_id='3m2ynttfsqwn6'  order by TIMESTAMP;
select COST,CPU_COST,IO_COST,PLAN_HASH_VALUE,OBJECT_NAME,TIMESTAMP  from DBA_HIST_SQL_PLAN where sql_id='&1'  order by TIMESTAMP;
select sum(COST),sum(CPU_COST),sum(IO_COST),PLAN_HASH_VALUE,TIMESTAMP  from DBA_HIST_SQL_PLAN where sql_id='&1'  group by PLAN_HASH_VALUE,TIMESTAMP order by TIMESTAMP;

   
 10g 日志监听：
 set log_status off
 set log_status on
 
 dba_audit_trail
 select USERNAME,USERHOST,OS_USERNAME,RETURNCODE,TIMESTAMP from dba_audit_trail where RETURNCODE=1017 and TIMESTAMP>sysdate-3
 


FAGLFLEXA
BDCPS

热快查询：

SQL> 1
  1* select FILE#,DBABLK,TCH,OBJ from x$bh  where TCH >100 order by TCH
SQL> select sum(TCH),OBJ from x$bh  where tch>100 group by OBJ having sum(TCH)>1000 order sum(TCH);
select sum(TCH),OBJ from x$bh  where tch>100 group by OBJ having sum(TCH)>1000 order by sum(TCH)
                                                                                    

SQL> select sum(TCH),OBJ from x$bh  where tch>100 group by OBJ having sum(TCH)>1000 order by sum(TCH);

select sum(bytes)/1024/1024,segment_name,owner from dba_segments where segment_name in('LFA1','PA0001','ZSGETVTBDHEAD','DD04L','DD04T','CSKS','REPOSRC') group by segment_name,owner ;

 alter table sapsr3.PA0001 cache;
 alter table sapsr3.ZSGETVTBDHEAD cache;
 alter table sapsr3.LFA1 cache;
 alter table sapsr3.DD04L cache;
 alter table sapsr3.CSKS cache;
 alter table sapsr3.DD04T cache;




alter session set current_schema=hneic;
SQL> explain plan for  SELECT COUNT(1) FROM A_PAY_FLOW A,PUB_A_PAY_RELA B,C_CONS C
  2               WHERE A.CHARGE_ID=B.CHARGE_ID AND A.CONS_NO = C.CONS_NO AND
  3               A.CHARGE_EMP_NO=:1  AND A.CHARGE_DATE >=TO_DATE(:2,'YYYYMMDD')
  4               AND A.CHARGE_DATE <=TO_DATE(:3,'YYYYMMDD')+1  ORDER BY
  5               A.CHARGE_DATE
  6  /

Explained.

alter session set current_schema=sys;
@?/rdbms/admin/utlxpls

cgjzxwxqhascp

alter system dump datafile fileid block number;
oradebug setmypid;
oradebug tracefile_name;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('3buvw48uzq248'));
73gp23cqp59st
3buvw48uzq248

SELECT A.CHARGE_ID, A.CONS_NO, NVL(C.CONS_NAME, ' '), NVL(A.RCV_ORG_NO, ' '), A.RCV_AMT, NVL(B.THIS_PENALTY, 0), NVL(B.PREPAY_AMT, 0), A.CHARGE_EMP_NO, A.SETTLE_MODE FROM A_PAY_FLOW A, PUB_A_PAY_RELA B, C_CONS C WHERE A.CHARGE_ID=B.CHARGE_ID AND A.CONS_NO = C.CONS_NO AND B.IS_VALID!=:1 AND A.PAY_MODE in (:2, :3, :4, :5, :6, :7, :8, :9, :10, :11, :12, :13) AND A.CHARGE_DATE>=TO_DATE(:14, 'YYYYMMDD') AND A.CHARGE_DATE<=TO_DATE(:15, 'YYYYMMDD')+1 AND A.ORG_NO LIKE :16 || '%' AND A.CONS_NO =:17 ORDER BY A.CHARGE_ID DESC 



explain plan for SELECT COUNT(1) FROM A_PAY_FLOW A, PUB_A_PAY_RELA B, C_CONS C WHERE A.CHARGE_ID=B.CHARGE_ID AND A.CONS_NO = C.CONS_NO AND A.CHARGE_EMP_NO=:1 AND A.CHARGE_DATE >=TO_DATE(:2, 'YYYYMMDD') AND A.CHARGE_DATE <=TO_DATE(:3, 'YYYYMMDD')+1 ORDER BY A.CHARGE_DATE;

alter session set current_schema=sgpms;
explain plan for SELECT COUNT(1) FROM A_PAY_FLOW A, PUB_A_PAY_RELA B, C_CONS C WHERE A.CHARGE_ID=B.CHARGE_ID AND A.CONS_NO = C.CONS_NO AND A.CHARGE_EMP_NO=:1 AND A.CHARGE_DATE >=TO_DATE(:2, 'YYYYMMDD') AND A.CHARGE_DATE <=TO_DATE(:3, 'YYYYMMDD')+1 ORDER BY A.CHARGE_DATE;
alter session set current_schema=sys;
@?/rdbms/admin/utlxpls

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('73gp23cqp59st'));
73gp23cqp59st

set wra on
set long 999999
col task format a300
set serveroutput on size 999999
set LONGC 99999
set linesize 32000
set pagesize 9999
var  my_recomm   CLOB;
DECLARE
my_task_name VARCHAR2(30);
BEGIN
my_task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK( sql_id    => '&1' );
DBMS_SQLTUNE.EXECUTE_TUNING_TASK( task_name => my_task_name );
select DBMS_SQLTUNE.REPORT_TUNING_TASK( my_task_name ) into :my_recomm from dual;
END;
/

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR('897zrdwbxhrn7'));

dbms_shared_pool.purge
5uftkxxna2d89 
DBMS_SCHEDULER  INSERT INTO B_BILL_AMT SELECT ... 
10,344.12 246,256 0.04 3.46 88.46 0.10 
9fbphw5bq0k97 

----shared_pool ----
SQL> select address,hash_value||'' from v$sqlarea where sql_id='&1';
6bu0rtsvtdjg9
7z11cfytagdy1

ADDRESS          HASH_VALUE||''
---------------- ----------------------------------------
0000002DB9F40018 1141605382

0000002DF229A3F0 2779771877


C000001546EDE7A8 1755395337

00000040D52A2330 3139344481

SQL> exec sys.dbms_shared_pool.purge('C000001B1762A288,400055943','c');
0000002ECC809DE8 4123947061
exec DBMS_SQLTUNE.DROP_SQL_PROFILE('coe_bf4b4dvuwww1p_1094908358');

dba_hist_sql_plan
select * from dba_hist_sql_plan where sql_id='&1' order by PLAN_HASH_VALUE

alter session set current_schema=sgpms;




run{
allocate channel ch01 type 'sbt_tape';
send 'NB_ORA_SERV=nbumaster,NB_ORA_CLIENT=hncjdb02';
blockcover datafie 1166 block 1494923;
release channel ch01;
}

监听负载均衡和failover:
PMDBAA =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = yxtest-scan)(PORT = 11521))
    (load_balance=yes) 负载均衡
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = pmdba)
     (failover_mode=
     (type=session) --preconnect
     (method=basic)
     (retries=180)
     (delay=5)
     )
    )


1. Select name,value from v$asm_attribute where group_number=1 and name like '% compatible.rdbms%';
如果低于11.2修改：
2.Alter diskgroup PMDBATEST set attribute 'compatible.rdbms'='11.2.0.0.0';
修改磁盘offline drop 时间。由原来的3.6小时改为24小时
3.Alter diskgroup PMDBATEST set attribute 'disk_repair_time'='24h';
检查修改。
4.Select name,value from v$asm_attribute where group_number=1 and name like '%disk_repair_time%';
5.Alter diskgroup diskgroupname offline disk xxx_xxx;
6.alter diskgroup diskgroupname offline disks in failgroup groupname fg1;
存储节点1停用
SQL> select FAILGROUP,name,path,GROUP_NUMBER from v$asm_disk  where FAILGROUP like '%FG1%' order by GROUP_NUMBER;
Select * from v$asm_attribute where group_number in ('3','4','9','10') and name like '%disk_repair_time%';
ALTER DISKGROUP PMDBDATAF ONLINE DISKS IN FAILGROUP FG1 POWER 8;
分区表键值：
DBA_SUBPART_KEY_COLUMNS 
DBA_PART_KEY_COLUMNS 

select NAME,OWNER,COLUMN_NAME from DBA_SUBPART_KEY_COLUMNS where owner='SGPMS'
分析步骤：
一、恢复源库10.223.52.50 MDS库中12月4日归档后使用LOGMINER挖掘归档日志信息

查询日志：

select NAME,FIRST_TIME from v$archived_log where FIRST_TIME >sysdate-0.5 order by FIRST_TIME
archived_log: 
时间字段说明：
FIRST_TIME        开始写redo时间。          
NEXT_TIME         开始写下一个redo时间,开始归档。
COMPLETION_TIME   归档完成时间。

EXEC dbms_logmnr.add_logfile(' +DATADG1/bpm/onlinelog/group_4.858.941124675',dbms_logmnr.new);
EXEC dbms_logmnr.add_logfile('+DATA/mpac/archivelog/2017_12_13/thread_1_seq_518.430.962618507',dbms_logmnr.addfile);
EXEC dbms_logmnr.add_logfile('+DATA/mpac/archivelog/2017_12_13/thread_1_seq_519.407.962618507',dbms_logmnr.addfile);   
EXEC dbms_logmnr.add_logfile('+DATA/mpac/archivelog/2017_12_13/thread_2_seq_6675.423.962618805',dbms_logmnr.addfile);   
EXEC dbms_logmnr.add_logfile('+DATA/mpac/archivelog/2017_12_13/thread_2_seq_6676.404.962618805',dbms_logmnr.addfile);   
EXEC dbms_logmnr.add_logfile('+DATA/mpac/archivelog/2017_12_13/thread_2_seq_6677.418.962618805',dbms_logmnr.addfile);   
exec dbms_logmnr.start_logmnr(options => dbms_logmnr.dict_from_online_catalog); 
二、将挖掘数据记录到test1表中                                                   
create table test2 as select * from v$logmnr_contents ;                         
分析：                                                                          
select /*+parallel(a,8)*/ TIMESTAMP,USERNAME,REDO_VALUE,UNDO_VALUE,SQL_REDO,SQL_UNDO from logdata a where table_name=upper('e_mp_day_read') and OPERATION='UPDATE' 
and (sql_redo like '%2012000013376553%' or  SQL_UNDO like '%2012000013376553%');

三、查询14号OGG未同步数据结果：

基表分析：
exec dbms_stats.gather_table_stats('SYS','UNDO$',estimate_percent=>100,method_opt=>'for columns flags size 254');

10G crs 自动启动
/etc/init.d/init.crs enable
      
禁用tfactl 
/oracle/app/11.2.0/grid/bin/tfactl disable       
/etc/init.d/init.tfa stop
/etc/init.d/init.tfa start


 
 监控一： 
六级事务锁持有时间超过5分钟报警。
select 'lock_blocking_num' lock_blocking_num, count(*) cnt from v$lock where TYPE in('TX','TM') and CTIME>300 and lmode=6 and block=1; ---5分钟报警

监控二:
六级事务锁持有时间超过5分钟报警。
select 'lock_blocking_5min' lock_blocking_5min, count(*) cnt from v$lock where TYPE in('TX','TM') and CTIME>300 and lmode=6 and block=1; ---5分钟报警

监控三：
session bloking :session 进程被阻塞 阻塞超过5分钟报警：
select 'session_bloking_5mins' session_bloking_5mins,count cnt  from v$session where BLOCKING_SESSION is not null and (sysdate-SQL_EXEC_START)*3600*24>300; --5分钟报警

监控四：
慢查询的SQL语句：查询
select 'slow_query_5mins' slow_query_5mins,count(*) cnt from v$session where BLOCKING_SESSION is null and (sysdate-SQL_EXEC_START)*3600*24>300;  ---5分钟报警
LOGON_TIME
select sql_id,(sysdate-LOGON_TIME)*3600*24 from v$session where BLOCKING_SESSION is not null and (sysdate-LOGON_TIME)*3600*24>300 order by sql_id;
select sql_id,(sysdate-SQL_EXEC_START)*3600*24 from v$session where BLOCKING_SESSION is null and (sysdate-SQL_EXEC_START)*3600*24>300 order by sql_id;
LOGON_TIME
select sql_id,(sysdate-LOGON_TIME)*3600*24 from v$session where BLOCKING_SESSION is null and (sysdate-LOGON_TIME)*3600*24>300 order by sql_id;

select sql_id,(sysdate-SQL_EXEC_START)*3600*24 from v$session where BLOCKING_SESSION is not null and (sysdate-SQL_EXEC_START)*3600*24>300 order by sql_id;
select wm_concat(SQL_ID),wm_concat((sysdate-SQL_EXEC_START)*3600*24) from gv$session where BLOCKING_SESSION is null and (sysdate-SQL_EXEC_START)*3600*24>300 order by sql_id;

select wm_concat(SQL_ID),wm_concat(trunc((sysdate-SQL_EXEC_START)*3600*24)) from v$session where BLOCKING_SESSION is null and (sysdate-SQL_EXEC_START)*3600*24>30000000 order by sql_id;

select JOB,LOG_USER,SCHEMA_USER,THIS_DATE,THIS_SEC,TOTAL_TIME,FAILURES,INSTANCE,to_char(NEXT_DATE,'yyyy-mm-dd') from 
dba_jobs where to_char(NEXT_DATE,'yyyy-mm-dd')>=to_char(sysdate,'yyyy-mm-dd') 
and LOG_USER='LLYS'
order by JOB;



5.打开闪回的注意几点：
参数：配置一下参数顺序不能变：不然会报错。一定要顺序执行。闪回去大小根据业务量确定。
alter system set db_recovery_file_dest_size=xxxxG sid='*';
alter system set db_recovery_file_dest='+data' sid='*';
alter database flashback on; ---可能时间会稍微长。
create restore point  xxxname;
 
set linesize 200
set wra off
select  s.SID,s.VALUE,n.name from v$sesstat s,v$statname n 
where s. STATISTIC# =n.STATISTIC#  and  NAME like '%memory%' and VALUE>10000 order by VALUE


dbms_job.instance(job in binary_intance,
                   instance in binary_integer,
                   force in boolean default false)
                   
dbms_job.instance(job=>80,instance=>1,force=>true)
exec dbms_job.instance(job=>80,instance=>1)
          
          
dba_col_comments
                 
                 
                
 
 
 select a.owner,b.table_name,a.cnt-b.cnt from 
(select OWNER,TABLE_NAME,count(*) cnt from all_tab_columns  group by OWNER,TABLE_NAME)a,
(select OWNER,TABLE_NAME,count(*) cnt from dba_tab_columns  group by OWNER,TABLE_NAME)b 
where a.owner=b.owner and b.TABLE_NAME=a.TABLE_NAME and (a.cnt-b.cnt)<>0

select * from dba_tab_cols where owner=upper('i6000_sys') and table_name=upper('sys_v_userroleorgrs');
dba_col_comments; 
dba_tab_cols

select * from dba_col_comments where owner=upper('i6000_sys') and table_name=upper('sys_v_userroleorgrs')

begin
sys.dbms_job.remove(9);
commit;
end;
日志信息路径：
v$diag_info

Health Monitor 
exec dbms_hm.run_check('Dictionary Integrity Check','iocheck');
select dbms_hm.get_run_report('iocheck') from dual;

v$hm_check 

RAC杀集群其他节点进程：
文档号： 869777.1
alter system kill session '2118,36794,pmdba2'  immediate;
alter system kill session '2118,36820,@2'  immediate;
用户多节点杀进程：
select 'alter system kill session '''||sid||','||serial#||','||'@'||inst_id||''''||' immediate;' from gv$session  where username=upper('DWZY') and PROGRAM='httpd@localhost.localdomain (TNS V1-V3)';
SQL_id 杀进程：
set wra off
set pagesize 999
select 'alter system kill session '''||sid||','||serial#||','||'@'||inst_id||''''||' immediate;' from gv$session  where sql_id='&1' and SQL_EXEC_START<sysdate-1/24;
5hcy5g7ca0a3w
分区表：
创建分区表：
drop table testpp;
create table testpp
(
id number not null,
dt date
)
partition by range(id)
(
partition testpp_p1 values less than(1000),
partition testpp_p2 values less than(2000)
);

_partition_large_extents=true
_partition_large_extents
deferred_segment_creation

alter system set deferred_segment_creation=true;---SYS用户不起作用!!!!!!!!!
alter system set "_partition_large_extents"=false; 
show parameter 
select sum(bytes)/1024/1024 from dba_segments where partition_name=upper('&1');

导入统计信息：
exec dbms_stats.create_stat_table (ownname => 'SGPMS', stattab => 'ST_T1', tblspace => 'USERS'); 
exec dbms_stats.export_table_stats(ownname =>'SGPMS',tabname=>'A_RCVBL_ENTRY',stattab=>'ST_T1',statid => 'A');
exec dbms_stats.import_table_stats(ownname => 'SGPMS', tabname => 'A_RCVBL_ENTRY', stattab => 'ST_T1', statid => 'A', no_invalidate => true); 

##############12C#################
adrci

######### 静态注册##########################
LISTENER1_PMHSDB01 =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = TCP)(HOST = pmhnsdb01-priv)(PORT = 11521)(IP = FIRST))
      (ADDRESS = (PROTOCOL = TCP)(HOST = 10.223.49.111)(PORT = 11521)(IP = FIRST))
    )
  )

SID_LIST_LISTENER1_PMHSDB01=
  ( SID_LIST =
    ( SID_DESC =
      (GLOBAL_DBNAME = middb)
      (ORACLE_HOME = /oracle/app/oracle/product/11.2.0/db_1 )
      (SID_NAME = middb1)
     )
  )

####################单节点报 ora-01157 ora-01110#####################
alter system check datafiles;
#####################################################################
alter system enable restricted session;
alter system disable restricted session;
##################################hanganalyze#################################
ALTER SESSION SET EVENTS 'immediate trace name HANGANALYZE level <level>';
ALTER SESSION SET EVENTS 'immediate trace name HANGANALYZE level 3';
Select spid from v$process where addr in(select paddr from v$session where sid in(select distinct sid from v$mystat));
TRC文件user_dump_dest 目录下 的 spid.trc ora_dbname_spid.trc 
oradebug –g all  hanganalyze 3;
oradebug tracefile_name;
ALTER SESSION SET EVENTS 'immediate trace name HANGANALYZE level 3';
###############################
set wra off
set linesize 200
col path format a40
set pagesize 999
select name,path,TOTAL_MB,FREE_MB,state from v$asm_disk where GROUP_NUMBER=10 order by path;
#########################
set wra off
set linesize 200
col path format a40
set pagesize 999
select name,path,TOTAL_MB,FREE_MB,state from v$asm_disk where GROUP_NUMBER=4 order by path;
PMDBDATA_0000                  /dev/oracleasm/disks/c1s1                    975608     243265 NORMAL
PMDBDATA_0001                  /dev/oracleasm/disks/c1s2                    975608     276411 NORMAL
PMDBDATA_0002                  /dev/oracleasm/disks/c1s3                    976224     292353 NORMAL
PMDBDATA_0003                  /dev/oracleasm/disks/c1s4                    976224     309545 NORMAL
PMDBDATA_0004                  /dev/oracleasm/disks/c1s5                    976224     282741 NORMAL
PMDBDATA_0005                  /dev/oracleasm/disks/c1s6                    976224     317580 NORMAL
PMDBDATA_0006                  /dev/oracleasm/disks/c1s7                    976224     309439 NORMAL
PMDBDATA_0007                  /dev/oracleasm/disks/c1s8                    976224     298367 NORMAL
alter diskgroup PMDBDATA drop disk PMDBDATA_0000;
alter diskgroup PMDBDATA drop disk PMDBDATA_0001;
alter diskgroup PMDBDATA drop disk PMDBDATA_0002;
alter diskgroup PMDBDATA drop disk PMDBDATA_0003;
alter diskgroup PMDBDATA drop disk PMDBDATA_0004;
alter diskgroup PMDBDATA drop disk PMDBDATA_0005;
alter diskgroup PMDBDATA drop disk PMDBDATA_0006;
alter diskgroup PMDBDATA drop disk PMDBDATA_0007;
select * from v$asm_diskgroup;
alter diskgroup PMDBDATA1 rebalance power 7;
alter diskgroup PMDBDATA rebalance power 7;

可插拔数据库资源管理使用情况：
dba_hist_rsrc_pdb_metric
###############################rman 还未备份的归档####################
select NAME,FIRST_TIME,BACKUP_COUNT,STANDBY_DEST from v$archived_log where FIRST_TIME>sysdate-1 and BACKUP_COUNT=0 and STANDBY_DEST='NO'
PMDBDATA_0002                  /dev/oracleasm/disks/c1s3                    976224     879475 DROPPING
PMDBDATA_0003                  /dev/oracleasm/disks/c1s4                    976224     882109 DROPPING

SQL> desc x$kffxp
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 ADDR                                               RAW(8)
 INDX                                               NUMBER
 INST_ID                                            NUMBER
 GROUP_KFFXP                                        NUMBER
 NUMBER_KFFXP                                       NUMBER
 COMPOUND_KFFXP                                     NUMBER
 INCARN_KFFXP                                       NUMBER
 PXN_KFFXP                                          NUMBER
 XNUM_KFFXP                                         NUMBER
 LXN_KFFXP                                          NUMBER
 DISK_KFFXP                                         NUMBER
 AU_KFFXP                                           NUMBER
 FLAGS_KFFXP                                        NUMBER
 CHK_KFFXP                                          NUMBER
 SIZE_KFFXP                                         NUMBER
